//gsl3680_touch.h

#ifndef _GT911_TOUCH_H
#define _GT911_TOUCH_H
#include <stdio.h>

class gsl3680_touch
{
public:
    gsl3680_touch(int8_t sda_pin, int8_t scl_pin, int8_t rst_pin = -1, int8_t int_pin = -1);

    void begin();
    bool getTouch(uint16_t *x, uint16_t *y);
    void set_rotation(uint8_t r);

private:
    int8_t _sda, _scl, _rst, _int;
};

#endif

//=====================================================

//gsl3680_touch.cpp

#include "sdkconfig.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_err.h"
#include "esp_log.h"
#include "driver/i2c.h"
#include "esp_lcd_touch.h"
#include "esp_lcd_gsl3680.h"
#include "gsl3680_touch.h"

#define CONFIG_LCD_HRES 800
#define CONFIG_LCD_VRES 1280

static const char *TAG = "example";

esp_lcd_touch_handle_t tp;
esp_lcd_panel_io_handle_t tp_io_handle;

uint16_t touch_strength[1];
uint8_t touch_cnt = 0;

gsl3680_touch::gsl3680_touch(int8_t sda_pin, int8_t scl_pin, int8_t rst_pin, int8_t int_pin)
{
    _sda = sda_pin;
    _scl = scl_pin;
    _rst = rst_pin;
    _int = int_pin;
}

void gsl3680_touch::begin()
{
    i2c_config_t i2c_conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = (gpio_num_t)_sda,
        .scl_io_num = (gpio_num_t)_scl,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
    };
    i2c_conf.master.clk_speed = 400000; // 400kHz

    ESP_ERROR_CHECK(i2c_param_config(I2C_NUM_0, &i2c_conf));
    ESP_ERROR_CHECK(i2c_driver_install(I2C_NUM_0, i2c_conf.mode, 0, 0, 0));

    esp_lcd_panel_io_i2c_config_t tp_io_config = ESP_LCD_TOUCH_IO_I2C_GSL3680_CONFIG();
    ESP_LOGI(TAG, "Initialize touch IO (I2C)");
    esp_lcd_new_panel_io_i2c((esp_lcd_i2c_bus_handle_t)I2C_NUM_0, &tp_io_config, &tp_io_handle);

    esp_lcd_touch_config_t tp_cfg = {
        .x_max = CONFIG_LCD_HRES,
        .y_max = CONFIG_LCD_VRES,
        .rst_gpio_num = (gpio_num_t)_rst,
        .int_gpio_num = (gpio_num_t)_int,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 1,
            .mirror_y = 1,
        },
    };

    ESP_LOGI(TAG, "Initialize touch controller gsl3680");
    ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_gsl3680(tp_io_handle, &tp_cfg, &tp));
}

bool gsl3680_touch::getTouch(uint16_t *x, uint16_t *y)
{
    esp_lcd_touch_read_data(tp);
    bool touchpad_pressed = esp_lcd_touch_get_coordinates(tp, x, y, touch_strength, &touch_cnt, 1);

    return touchpad_pressed;
}

void gsl3680_touch::set_rotation(uint8_t r){
switch(r){
    case 0:
        esp_lcd_touch_set_swap_xy(tp, false);   
        esp_lcd_touch_set_mirror_x(tp, false);
        esp_lcd_touch_set_mirror_y(tp, false);
        break;
    case 1:
        esp_lcd_touch_set_swap_xy(tp, false);
        esp_lcd_touch_set_mirror_x(tp, true);
        esp_lcd_touch_set_mirror_y(tp, true);
        break;
    case 2:
        esp_lcd_touch_set_swap_xy(tp, false);   
        esp_lcd_touch_set_mirror_x(tp, false);
        esp_lcd_touch_set_mirror_y(tp, false);
        break;
    case 3:
        esp_lcd_touch_set_swap_xy(tp, false);   
        esp_lcd_touch_set_mirror_x(tp, true);
        esp_lcd_touch_set_mirror_y(tp, true);
        break;
    }

}

//========================================================

//gsl_point_id.h

#ifndef _GSL_POINT_ID_H
#define _GSL_POINT_ID_H

struct gsl_touch_info
{
    int x[10];
    int y[10];
    int id[10];
    int finger_num;
};

unsigned int gsl_mask_tiaoping(void);
unsigned int gsl_version_id(void);
void gsl_alg_id_main(struct gsl_touch_info *cinfo);
void gsl_DataInit(unsigned int *conf_in);

#endif

//===========================================================

//gsl_point_id.c

/* drivers/input/touchscreen/mediatek/gslX680/
 *
 * 2010 - 2016 silead inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be a reference
 * to you, when you are integrating the sileadinc's CTP IC into your system,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 */
// #include "bsp/lcd_gsl3680.h"
#include "gsl_point_id.h"
#include "esp_log.h"
#include "stdio.h"

#define GSL_VERSION                                                            \
	0x20160901 /* NO GESTURE VERSION COME FROM VERSION 20150706 */

#ifndef NULL
#define NULL ((void *)0)
#endif
#ifndef UINT
#define UINT unsigned int
#endif

#define POINT_MAX 10
#define PP_DEEP 10
#define PS_DEEP 10
#define PR_DEEP 10
#define AVG_DEEP 5
#define POINT_DEEP (PP_DEEP + PS_DEEP + PR_DEEP)
#define PRESSURE_DEEP 8
#define INTE_INIT 8
#define CONFIG_LENGTH 512
#define TRUE 1
#define FALSE 0
#define FLAG_ABLE (0x4 << 12)
#define FLAG_FILL (0x2 << 12)
#define FLAG_KEY (0x1 << 12)
#define FLAG_COOR (0x0fff0fff)
#define FLAG_COOR_EX (0xffff0fff)
#define FLAG_ID (0xf0000000)

#define TAG "gsl_point_id"

// struct gsl_touch_info {
// 	int x[10];
// 	int y[10];
// 	int id[10];
// 	int finger_num;
// };

struct gsl_DISTANCE_TYPE {
	unsigned int i;
	unsigned int j;
	unsigned int min;		      /* distance min */
	unsigned int d[POINT_MAX][POINT_MAX]; /* distance; */
};

union gsl_POINT_TYPE {
	struct {
		unsigned y : 12;
		unsigned key : 1;
		unsigned fill : 1;
		unsigned able : 1;
		unsigned predict : 1;
		unsigned x : 16;
	} other;
	struct {
		unsigned y : 13;
		unsigned rev_2 : 3;
		unsigned x : 16;
	} dis;
	unsigned int all;
};

union gsl_DELAY_TYPE {
	struct {
		unsigned delay : 8;
		unsigned report : 8;
		unsigned dele : 8;
		unsigned rev_1 : 4;
		unsigned pres : 1;
		unsigned mask : 1;
		unsigned able : 1;
		unsigned init : 1;
	} other;
	unsigned int all;
};

union gsl_STATE_TYPE {
	struct {
		unsigned rev_0 : 8;
		unsigned rev_1 : 8;

		unsigned rev_2 : 4;
		unsigned active_prev : 1;
		unsigned menu : 1;
		unsigned cc_128 : 1;
		unsigned ex : 1;

		unsigned interpolation : 4;
		unsigned active : 1;
		unsigned only : 1;
		unsigned mask : 1;
		unsigned reset : 1;
	} other;
	unsigned int all;
};

struct gsl_EDGE_TYPE {
	unsigned int rate;
	unsigned int dis;
	union gsl_POINT_TYPE coor;
};

union gsl_DECIMAL_TYPE {
	struct {
		short y;
		short x;
	} other;
	unsigned int all;
};

union gsl_FLAG_TYPE {
	struct {
		unsigned over_report_mask : 1;
		unsigned opposite_x : 1;
		unsigned opposite_y : 1;
		unsigned opposite_xy : 1;
		unsigned line : 1;
		unsigned line_neg : 1;
		unsigned line_half : 1;
		unsigned middle_drv : 1;

		unsigned key_only_one : 1;
		unsigned key_line : 1;
		unsigned refe_rt : 1;
		unsigned refe_var : 1;
		unsigned base_median : 1;
		unsigned key_rt : 1;
		unsigned refe_reset : 1;
		unsigned sub_cross : 1;

		unsigned row_neg : 1;
		unsigned sub_line_coe : 1;
		unsigned sub_row_coe : 1;
		unsigned c2f_able : 1;
		unsigned thumb : 1;
		unsigned graph_h : 1;
		unsigned init_repeat : 1;
		unsigned near_reset_able : 1;

		unsigned emb_dead : 1;
		unsigned emb_point_mask : 1;
		unsigned interpolation : 1;
		unsigned sum2_able : 1;
		unsigned reduce_pin : 1;
		unsigned drv_order_ex : 1;
		unsigned id_over : 1;
		unsigned rev_1 : 1;
	} other;
	unsigned int all;
};
union gsl_ID_FLAG_TYPE {
	struct {
		unsigned reso_y : 1;
		unsigned reso_x : 1;
		unsigned screen_core : 1;
		unsigned screen_real : 1;
		unsigned ignore_pri : 1;
		unsigned id_prec_able : 1;
		unsigned first_avg : 1;
		unsigned round : 1;

		unsigned stretch_off : 1;
		unsigned rev_7 : 7;

		unsigned rev_x : 16;
	} other;
	unsigned int all;
};
static union {
	struct {
		unsigned char id;
		unsigned char num;
		unsigned char rev_1;
		unsigned char rev_2;
	} other;
	unsigned int all;
} prec_id;

static union gsl_POINT_TYPE point_array[POINT_DEEP][POINT_MAX];
static union gsl_POINT_TYPE *point_pointer[PP_DEEP];
static union gsl_POINT_TYPE *point_stretch[PS_DEEP];
static union gsl_POINT_TYPE *point_report[PR_DEEP];
static union gsl_POINT_TYPE point_now[POINT_MAX];
static union gsl_DELAY_TYPE point_delay[POINT_MAX];
static int filter_deep[POINT_MAX];
static int avg[AVG_DEEP];
static struct gsl_EDGE_TYPE point_edge;
static union gsl_DECIMAL_TYPE point_decimal[POINT_MAX];

static unsigned int pressure_now[POINT_MAX];
static unsigned int pressure_array[PRESSURE_DEEP][POINT_MAX];
static unsigned int pressure_report[POINT_MAX];
static unsigned int *pressure_pointer[PRESSURE_DEEP];

#define pp point_pointer
#define ps point_stretch
#define pr point_report
#define point_predict pp[0]
#define pa pressure_pointer

static union gsl_STATE_TYPE global_state;
static int inte_count;
static unsigned int csensor_count;
static int point_n;
static int point_num;
static int prev_num;
static int point_near;
static unsigned int point_shake;
static unsigned int reset_mask_send;
static unsigned int reset_mask_max;
static unsigned int reset_mask_count;
static union gsl_FLAG_TYPE global_flag;
static union gsl_ID_FLAG_TYPE id_flag;
static unsigned int id_first_coe;
static unsigned int id_speed_coe;
static unsigned int id_static_coe;
static unsigned int average;
static unsigned int soft_average;
static unsigned int report_delay;
static unsigned int delay_key;
static unsigned int report_ahead;
static unsigned int report_delete;
static unsigned char median_dis[4];
static unsigned int shake_min;
static int match_y[2];
static int match_x[2];
static int ignore_y[2];
static int ignore_x[2];
static int screen_y_max;
static int screen_x_max;
static int point_num_max;
static unsigned int drv_num;
static unsigned int sen_num;
static unsigned int drv_num_nokey;
static unsigned int sen_num_nokey;
static unsigned int coordinate_correct_able;
static unsigned int coordinate_correct_coe_x[64];
static unsigned int coordinate_correct_coe_y[64];
static unsigned int edge_cut[4];
static unsigned int stretch_array[4 * 4 * 2];
static unsigned int stretch_active[4 * 4 * 2];
static unsigned int shake_all_array[2 * 8];
static unsigned int edge_start;
static unsigned int reset_mask_dis;
static unsigned int reset_mask_type;
static unsigned int key_map_able;
static unsigned int key_range_array[8 * 3];
static int filter_able;
static unsigned int filter_coe[4];
static unsigned int multi_x_array[4], multi_y_array[4];
static unsigned int multi_group[4][64];
static int ps_coe[4][8], pr_coe[4][8];
static int point_repeat[2];
/* static	int near_set[2]; */
static int diagonal;
static int point_extend;
static unsigned int press_mask;
static union gsl_POINT_TYPE point_press_move;
static unsigned int press_move;
/* unsigned int key_dead_time			; */
/* unsigned int point_dead_time		; */
/* unsigned int point_dead_time2		; */
/* unsigned int point_dead_distance	; */
/* unsigned int point_dead_distance2	; */
/* unsigned int pressure_able; */
/* unsigned int pressure_save[POINT_MAX]; */
static unsigned int edge_first;
static unsigned int edge_first_coe;
static unsigned int point_corner;
static unsigned int stretch_mult;
/* ------------------------------------------------- */
static unsigned int config_static[CONFIG_LENGTH];
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
static void SortBubble(int t[], int size)
{
	int temp = 0;
	int m, n;

	for (m = 0; m < size; m++) {
		for (n = m + 1; n < size; n++) {
			temp = t[m];
			if (temp > t[n]) {
				t[m] = t[n];
				t[n] = temp;
			}
		}
	}
}

static int Sqrt(int d)
{
	int ret = 0;
	int i;

	for (i = 14; i >= 0; i--) {
		if ((ret + (0x1 << i)) * (ret + (0x1 << i)) <= d)
			ret |= (0x1 << i);
	}
	return ret;
}

static UINT PointRange(int x0, int y0, int x1, int y1)
{
	if (x0 < 1) /* && x1>=1 */ {
		if (x0 != x1)
			y0 = y1 + (y0 - y1) * (1 - x1) / (x0 - x1);
		x0 = 1;
	}
	if (x0 >= (int)drv_num_nokey * 64) {
		if (x0 != x1)
			y0 = y1 +
			     (y0 - y1) * ((int)drv_num_nokey * 64 - x1) /
				     (x0 - x1);
		x0 = drv_num_nokey * 64 - 1;
	}
	if (y0 < 1) {
		if (y0 != y1)
			x0 = x1 + (x0 - x1) * (1 - y1) / (y0 - y1);
		y0 = 1;
	}
	if (y0 >= (int)sen_num_nokey * 64) {
		if (y0 != y1)
			x0 = x1 +
			     (x0 - x1) * ((int)sen_num_nokey * 64 - y1) /
				     (y0 - y1);
		y0 = sen_num_nokey * 64 - 1;
	}
	if (x0 < 1)
		x0 = 1;
	if (x0 >= (int)drv_num_nokey * 64)
		x0 = drv_num_nokey * 64 - 1;
	if (y0 < 1)
		y0 = 1;
	if (y0 >= (int)sen_num_nokey * 64)
		y0 = sen_num_nokey * 64 - 1;
	return (x0 << 16) + y0;
}

static void PointCoor(void)
{
	int i;

	for (i = 0; i < point_num; i++) {
		if (global_state.other.ex)
			point_now[i].all &=
				(FLAG_COOR_EX | FLAG_KEY | FLAG_ABLE);
		else
			point_now[i].all &= (FLAG_COOR | FLAG_KEY | FLAG_ABLE);
	}
}

static void PointRepeat(void)
{
	int i, j;
	int x, y;
	int x_min, x_max, y_min, y_max;
	int pn;

	if (point_near)
		point_near--;
	if (prev_num > point_num)
		point_near = 8;
	if (point_repeat[0] == 0 || point_repeat[1] == 0) {
		if (point_near)
			pn = 96;
		else
			pn = 32;
	} else {
		if (point_near)
			pn = point_repeat[1];
		else
			pn = point_repeat[0];
	}
	for (i = 0; i < POINT_MAX; i++) {
		if (point_now[i].all == 0)
			continue;
		if (point_now[i].other.key)
			continue;
		x_min = point_now[i].other.x - pn;
		x_max = point_now[i].other.x + pn;
		y_min = point_now[i].other.y - pn;
		y_max = point_now[i].other.y + pn;
		for (j = i + 1; j < POINT_MAX; j++) {
			if (point_now[j].all == 0)
				continue;
			if (point_now[j].other.key)
				continue;
			x = point_now[j].other.x;
			y = point_now[j].other.y;
			if (x > x_min && x < x_max && y > y_min && y < y_max) {
				point_now[i].other.x =
					(point_now[i].other.x +
					 point_now[j].other.x + 1) /
					2;
				point_now[i].other.y =
					(point_now[i].other.y +
					 point_now[j].other.y + 1) /
					2;
				point_now[j].all = 0;
				pressure_now[i] =
					pressure_now[i] > pressure_now[j]
						? pressure_now[i]
						: pressure_now[j];
				pressure_now[j] = 0;
				i--;
				point_near = 8;
				break;
			}
		}
	}
	for (i = 0, j = 0; i < point_num; i++) {
		if (point_now[i].all == 0)
			continue;
		point_now[j].all = point_now[i].all;
		pressure_now[j++] = pressure_now[i];
	}
	point_num = j;
	for (; j < POINT_MAX; j++) {
		point_now[j].all = 0;
		pressure_now[j] = 0;
	}
}

static void PointPointer(void)
{
	int i, pn;

	point_n++;
	if (point_n >= PP_DEEP * PS_DEEP * PR_DEEP * PRESSURE_DEEP)
		point_n = 0;
	pn = point_n % PP_DEEP;
	for (i = 0; i < PP_DEEP; i++) {
		pp[i] = point_array[pn];
		if (pn == 0)
			pn = PP_DEEP - 1;
		else
			pn--;
	}
	pn = point_n % PS_DEEP;
	for (i = 0; i < PS_DEEP; i++) {
		ps[i] = point_array[pn + PP_DEEP];
		if (pn == 0)
			pn = PS_DEEP - 1;
		else
			pn--;
	}
	pn = point_n % PR_DEEP;
	for (i = 0; i < PR_DEEP; i++) {
		pr[i] = point_array[pn + PP_DEEP + PS_DEEP];
		if (pn == 0)
			pn = PR_DEEP - 1;
		else
			pn--;
	}
	pn = point_n % PRESSURE_DEEP;
	for (i = 0; i < PRESSURE_DEEP; i++) {
		pa[i] = pressure_array[pn];
		if (pn == 0)
			pn = PRESSURE_DEEP - 1;
		else
			pn--;
	}

	for (i = 0; i < POINT_MAX; i++) {
		pp[0][i].all = 0;
		ps[0][i].all = 0;
		pr[0][i].all = 0;
		pa[0][i] = 0;
	}
}

static unsigned int CC128(unsigned int x, unsigned int **coe, int k)
{
	if (k == 3) {
		return (x & ~127) + (coe[((x >> 6) & 1) ^ 1][x & 63] & 127);
	} else if (k == 4) {
		if (x & 128)
			return (x & ~127) + 127 -
			       (coe[(((127 - (x & 127)) >> 6) & 1) ^ 1]
				   [(127 - (x & 127)) & 63] &
				127);
		else
			return (x & ~127) +
			       (coe[((x >> 6) & 1) ^ 1][x & 63] & 127);
	}
	return 0;
}
static unsigned int CCO(unsigned int x, unsigned int coe[], int k)
{
	if (k == 0) {
		if (x & 32)
			return (x & ~31) + (31 - (coe[31 - (x & 31)] & 31));
		else
			return (x & ~31) + (coe[x & 31] & 31);
	}
	if (k == 1) {
		if (x & 64)
			return (x & ~63) + (63 - (coe[63 - (x & 63)] & 63));
		else
			return (x & ~63) + (coe[x & 63] & 63);
	}
	if (k == 2)
		return (x & ~63) + (coe[x & 63] & 63);

	return 0;
}

static void CoordinateCorrect(void)
{
	struct MULTI_TYPE {
		unsigned int range;
		unsigned int group;
	};
#ifdef LINE_MULTI_SIZE
#define LINE_SIZE LINE_MULTI_SIZE
#else
#define LINE_SIZE 4
#endif
	int i, j;
	unsigned int *px[LINE_SIZE + 1], *py[LINE_SIZE + 1];
	struct MULTI_TYPE multi_x[LINE_SIZE], multi_y[LINE_SIZE];
	unsigned int edge_size = 64;
	int kx, ky;

	if ((coordinate_correct_able & 0xf) == 0)
		return;
	kx = (coordinate_correct_able >> 4) & 0xf;
	ky = (coordinate_correct_able >> 8) & 0xf;
	px[0] = coordinate_correct_coe_x;
	py[0] = coordinate_correct_coe_y;
	for (i = 0; i < LINE_SIZE; i++) {
		px[i + 1] = NULL;
		py[i + 1] = NULL;
		multi_x[i].range = 0;
		multi_x[i].group = 0;
		multi_y[i].range = 0;
		multi_y[i].group = 0;
	}
	if (kx == 3 || ky == 3 || kx == 4 || ky == 4) {
		i = 0;
		if (kx == 3 || kx == 4)
			px[1] = multi_group[i++];
		if (ky == 3 || ky == 4)
			py[1] = multi_group[i++];
	} else {
		for (i = 0; i < LINE_SIZE; i++) {
			multi_x[i].range = multi_x_array[i] & 0xffff;
			multi_x[i].group = multi_x_array[i] >> 16;
			multi_y[i].range = multi_y_array[i] & 0xffff;
			multi_y[i].group = multi_y_array[i] >> 16;
		}
		j = 1;
		for (i = 0; i < LINE_SIZE; i++)
			if (multi_x[i].range && multi_x[i].group < LINE_SIZE)
				px[j++] = multi_group[multi_x[i].group];
		j = 1;
		for (i = 0; i < LINE_SIZE; i++)
			if (multi_y[i].range && multi_y[i].group < LINE_SIZE)
				py[j++] = multi_group[multi_y[i].group];
	}
	for (i = 0; i < (int)point_num && i < POINT_MAX; i++) {
		if (point_now[i].all == 0)
			break;
		if (point_now[i].other.key != 0)
			continue;
		if (point_now[i].other.x >= edge_size &&
		    point_now[i].other.x <= drv_num_nokey * 64 - edge_size) {
			if (global_state.other.active) {
				point_now[i].other.x =
					CCO(point_now[i].other.x,
					    multi_group[LINE_SIZE - 2], 2);
			} else if ((kx == 3 || kx == 4) &&
				   global_state.other.cc_128) {
				point_now[i].other.x =
					CC128(point_now[i].other.x, px, kx);
			} else if (kx == 3) {
				if (point_now[i].other.x & 64)
					point_now[i].other.x = CCO(
						point_now[i].other.x, px[0], 2);
				else
					point_now[i].other.x = CCO(
						point_now[i].other.x, px[1], 2);
			} else {
				for (j = 0; j < LINE_SIZE + 1; j++) {
					if (!(j >= LINE_SIZE ||
					      px[j + 1] == NULL ||
					      multi_x[j].range == 0 ||
					      point_now[i].other.x <
						      multi_x[j].range))
						continue;
					point_now[i].other.x =
						CCO(point_now[i].other.x, px[j],
						    kx);
					break;
				}
			}
		}
		if (point_now[i].other.y >= edge_size &&
		    point_now[i].other.y <= sen_num_nokey * 64 - edge_size) {
			if (global_state.other.active) {
				point_now[i].other.y =
					CCO(point_now[i].other.y,
					    multi_group[LINE_SIZE - 1], 2);
			} else if ((ky == 3 || ky == 4) &&
				   global_state.other.cc_128) {
				point_now[i].other.y =
					CC128(point_now[i].other.y, py, ky);
			} else if (ky == 3) {
				if (point_now[i].other.y & 64)
					point_now[i].other.y = CCO(
						point_now[i].other.y, py[0], 2);
				else
					point_now[i].other.y = CCO(
						point_now[i].other.y, py[1], 2);
			} else {
				for (j = 0; j < LINE_SIZE + 1; j++) {
					if (!(j >= LINE_SIZE ||
					      py[j + 1] == NULL ||
					      multi_y[j].range == 0 ||
					      point_now[i].other.y <
						      multi_y[j].range))
						continue;
					point_now[i].other.y =
						CCO(point_now[i].other.y, py[j],
						    ky);
					break;
				}
			}
		}
	}
#undef LINE_SIZE
}

static void PointPredictOne(unsigned int n)
{
	pp[0][n].all = pp[1][n].all & FLAG_COOR;
	pp[0][n].other.predict = 0;
}

static void PointPredictD2(unsigned int n)
{
	int x, y;

	x = (int)pp[1][n].other.x * 2 - (int)pp[3][n].other.x;
	y = (int)pp[1][n].other.y * 2 - (int)pp[3][n].other.y;
	pp[0][n].all = PointRange(x, y, pp[1][n].other.x, pp[1][n].other.y);
	pp[0][n].other.predict = 1;
}
static void PointPredictTwo(unsigned int n)
{
	int x, y;

	x = pp[1][n].other.x * 2 - pp[2][n].other.x;
	y = pp[1][n].other.y * 2 - pp[2][n].other.y;
	pp[0][n].all = PointRange(x, y, pp[1][n].other.x, pp[1][n].other.y);
	pp[0][n].other.predict = 1;
}

static void PointPredictSpeed(unsigned int n)
{
	int x, y;

	x = ((int)pp[1][n].other.x - (int)pp[2][n].other.x) * avg[0] / avg[1] +
	    (int)pp[1][n].other.x;
	y = ((int)pp[1][n].other.y - (int)pp[2][n].other.y) * avg[0] / avg[1] +
	    (int)pp[1][n].other.y;
	pp[0][n].all = PointRange(x, y, pp[1][n].other.x, pp[1][n].other.y);
	pp[0][n].other.predict = 1;
}
static void PointPredictD3(unsigned int n)
{
	int x, y;

	x = (int)pp[1][n].other.x * 5 + (int)pp[5][n].other.x -
	    (int)pp[3][n].other.x * 4;
	x /= 2;
	y = (int)pp[1][n].other.y * 5 + (int)pp[5][n].other.y -
	    (int)pp[3][n].other.y * 4;
	y /= 2;
	pp[0][n].all = PointRange(x, y, pp[1][n].other.x, pp[1][n].other.y);
	pp[0][n].other.predict = 1;
}

static void PointPredictThree(unsigned int n)
{
	int x, y;

	x = pp[1][n].other.x * 5 + pp[3][n].other.x - pp[2][n].other.x * 4;
	x /= 2;
	y = pp[1][n].other.y * 5 + pp[3][n].other.y - pp[2][n].other.y * 4;
	y /= 2;
	pp[0][n].all = PointRange(x, y, pp[1][n].other.x, pp[1][n].other.y);
	pp[0][n].other.predict = 1;
}

static void PointPredict(void)
{
	int i;

	for (i = 0; i < POINT_MAX; i++) {
		if (pp[1][i].all != 0) {
			if (global_state.other.interpolation != 0 &&
			    global_state.other.interpolation != INTE_INIT &&
			    pp[3][i].all && pp[3][i].other.fill == 0) {
				if (pp[4][i].all && pp[5][i].all &&
				    pp[5][i].other.fill == 0)
					PointPredictD3(i);
				else
					PointPredictD2(i);
			} else if (global_state.other.interpolation ||
				   pp[2][i].all == 0 ||
				   pp[2][i].other.fill != 0 ||
				   pp[3][i].other.fill != 0 ||
				   pp[1][i].other.key != 0 ||
				   global_state.other.only) {
				PointPredictOne(i);
			} else if (pp[2][i].all != 0 &&
				   (avg[0] != avg[1] || avg[1] != avg[2]) &&
				   avg[0] != 0 && avg[1] != 0) {
				PointPredictSpeed(i);
			} else if (pp[2][i].all != 0) {
				if (pp[3][i].all != 0)
					PointPredictThree(i);
				else
					PointPredictTwo(i);
			}
			pp[0][i].all |= FLAG_FILL;
			pa[0][i] = pa[1][i];
		} else
			pp[0][i].all = 0x0fff0fff;
		if (pp[1][i].other.key)
			pp[0][i].all |= FLAG_KEY;
	}
}

static unsigned int PointDistance(union gsl_POINT_TYPE *p1,
				  union gsl_POINT_TYPE *p2)
{
	int a, b, ret;

	if (id_flag.other.reso_y) {
		a = p1->dis.x;
		b = p2->dis.x;
		ret = (a - b) * (a - b);
		a = p1->dis.y * 64 * (int)screen_y_max / (int)screen_x_max *
		    ((int)drv_num_nokey * 64) / ((int)sen_num_nokey * 64) / 64;
		b = p2->dis.y * 64 * (int)screen_y_max / (int)screen_x_max *
		    ((int)drv_num_nokey * 64) / ((int)sen_num_nokey * 64) / 64;
		ret += (a - b) * (a - b);
	} else if (id_flag.other.reso_x) {
		a = p1->dis.x * 64 * (int)screen_x_max / (int)screen_y_max *
		    ((int)sen_num_nokey * 64) / ((int)drv_num_nokey * 64) / 64;
		b = p2->dis.x * 64 * (int)screen_x_max / (int)screen_y_max *
		    ((int)sen_num_nokey * 64) / ((int)drv_num_nokey * 64) / 64;
		ret = (a - b) * (a - b);
		a = p1->dis.y;
		b = p2->dis.y;
		ret += (a - b) * (a - b);
	} else {
		a = p1->dis.x;
		b = p2->dis.x;
		ret = (a - b) * (a - b);
		a = p1->dis.y;
		b = p2->dis.y;
		ret += (a - b) * (a - b);
	}
	return ret;
}

static void DistanceInit(struct gsl_DISTANCE_TYPE *p)
{
	int i;
	unsigned int *p_int = &(p->d[0][0]);

	for (i = 0; i < POINT_MAX * POINT_MAX; i++)
		*p_int++ = 0x7fffffff;
}

static int DistanceMin(struct gsl_DISTANCE_TYPE *p)
{
	int i, j;

	p->min = 0x7fffffff;
	for (j = 0; j < POINT_MAX; j++) {
		for (i = 0; i < POINT_MAX; i++) {
			if (p->d[j][i] < p->min) {
				p->i = i;
				p->j = j;
				p->min = p->d[j][i];
			}
		}
	}
	if (p->min == 0x7fffffff)
		return 0;
	return 1;
}

static void DistanceIgnore(struct gsl_DISTANCE_TYPE *p)
{
	int i, j;

	for (i = 0; i < POINT_MAX; i++)
		p->d[p->j][i] = 0x7fffffff;
	for (j = 0; j < POINT_MAX; j++)
		p->d[j][p->i] = 0x7fffffff;
}

static int SpeedGet(int d)
{
	int i;

	for (i = 8; i > 0; i--) {
		if (d > 0x100 << i)
			break;
	}
	return i;
}

static void PointId(void)
{
	int i, j;
	struct gsl_DISTANCE_TYPE distance;
	unsigned int id_speed[POINT_MAX];

	DistanceInit(&distance);
	for (i = 0; i < POINT_MAX; i++) {
		if (pp[0][i].other.predict == 0 || pp[1][i].other.fill != 0)
			id_speed[i] = id_first_coe;
		else {
			id_speed[i] =
				SpeedGet(PointDistance(&pp[1][i], &pp[0][i]));
			j = SpeedGet(PointDistance(&pp[2][i], &pp[1][i]));
			if (id_speed[i] < (unsigned int)j)
				id_speed[i] = j;
		}
	}
	for (i = 0; i < POINT_MAX; i++) {
		if (pp[0][i].all == FLAG_COOR)
			continue;
		for (j = 0; j < point_num && j < POINT_MAX; j++)
			distance.d[j][i] =
				PointDistance(&point_now[j], &pp[0][i]);
	}
	if (point_num == 0)
		return;
	if (global_state.other.only || global_state.other.active) {
		do {
			if (DistanceMin(&distance)) {
				if (pp[1][0].all != 0 &&
				    pp[1][0].other.key !=
					    point_now[distance.j].other.key) {
					DistanceIgnore(&distance);
					break; /*continue;*/
				}
				pp[0][0].all = point_now[distance.j].all;
			} else
				pp[0][0].all = point_now[0].all;
			for (i = 0; i < POINT_MAX; i++)
				point_now[i].all = 0;
		} while (0);
		point_num = 1;
	} else {
		for (j = 0; j < point_num && j < POINT_MAX; j++) {
			if (DistanceMin(&distance) == 0)
				break;
			if (distance.min >=
			    (id_static_coe +
			     id_speed[distance.i] * id_speed_coe)
			    /**average/(soft_average+1)*/) {
				/* point_now[distance.j].id = 0xf;//new id */
				continue;
			}
			pp[0][distance.i].all = point_now[distance.j].all;
			pa[0][distance.i] = pressure_now[distance.j];
			point_now[distance.j].all = 0;
			DistanceIgnore(&distance);
		}
	}
}

static int ClearLenPP(int i)
{
	int n;

	for (n = 0; n < PP_DEEP; n++) {
		if (pp[n][i].all)
			break;
	}
	return n;
}

static void PointNewId(void)
{
	int id, j;

	for (j = 0; j < POINT_MAX; j++)
		if ((pp[0][j].all & FLAG_COOR) == FLAG_COOR)
			pp[0][j].all = 0;
	for (j = 0; j < POINT_MAX; j++) {
		if (point_now[j].all != 0) {
			if (point_now[j].other.able)
				continue;
			for (id = 1; id <= POINT_MAX; id++) {
				if (ClearLenPP(id - 1) > (int)(1 + 1)) {
					pp[0][id - 1].all = point_now[j].all;
					pa[0][id - 1] = pressure_now[j];
					point_now[j].all = 0;
					break;
				}
			}
		}
	}
}

static void PointOrder(void)
{
	int i;

	for (i = 0; i < POINT_MAX; i++) {
		if (pp[0][i].other.fill == 0)
			continue;
		if (pp[1][i].all == 0 || pp[1][i].other.fill != 0 ||
		    filter_able == 0 || filter_able == 1) {
			pp[0][i].all = 0;
			pressure_now[i] = 0;
		}
	}
}

static void PointCross(void)
{
	unsigned int i, j;
	unsigned int t;

	for (j = 0; j < POINT_MAX; j++) {
		for (i = j + 1; i < POINT_MAX; i++) {
			if (pp[0][i].all == 0 || pp[0][j].all == 0 ||
			    pp[1][i].all == 0 || pp[1][j].all == 0)
				continue;
			if (((pp[0][j].other.x < pp[0][i].other.x &&
			      pp[1][j].other.x > pp[1][i].other.x) ||
			     (pp[0][j].other.x > pp[0][i].other.x &&
			      pp[1][j].other.x < pp[1][i].other.x)) &&
			    ((pp[0][j].other.y < pp[0][i].other.y &&
			      pp[1][j].other.y > pp[1][i].other.y) ||
			     (pp[0][j].other.y > pp[0][i].other.y &&
			      pp[1][j].other.y < pp[1][i].other.y))) {
				t = pp[0][i].all;
				pp[0][i].all = pp[0][j].all;
				pp[0][j].all = t;
				t = pa[0][i];
				pa[0][i] = pa[0][j];
				pa[0][j] = t;
			}
		}
	}
}

static void GetPointNum(union gsl_POINT_TYPE *pt)
{
	int i;

	point_num = 0;
	for (i = 0; i < POINT_MAX; i++)
		if (pt[i].all != 0)
			point_num++;
}

static unsigned int PointDelayAvg(int i)
{
	UINT j, len;
	int sum_x = 0;
	int sum_y = 0;

	if (id_flag.other.first_avg == 0)
		return TRUE;
	if (pp[0][i].all) {
		for (j = 0; j <= point_delay[i].other.report; j++) {
			sum_x += pp[j][i].other.x;
			sum_y += pp[j][i].other.y;
		}
		sum_x /= j;
		sum_y /= j;
		for (j = 0; j <= point_delay[i].other.report; j++) {
			ps[j][i].other.x = sum_x;
			ps[j][i].other.y = sum_y;
			pr[j][i].other.x = sum_x;
			pr[j][i].other.y = sum_y;
		}
		return TRUE;
	}
	if (pp[1][i].all == 0)
		return FALSE;
	for (j = 1; j <= point_delay[i].other.delay; j++)
		if (pp[j][i].all == 0)
			break;
	len = j - 1;
	if (len <
	    1 + (point_delay[i].other.delay - point_delay[i].other.report))
		return FALSE;
	len -= (point_delay[i].other.delay - point_delay[i].other.report);
	for (j = 1; j <= len; j++) {
		sum_x += pp[j][i].other.x;
		sum_y += pp[j][i].other.y;
	}
	if (j - 1 == 0)
		return FALSE;
	sum_x /= j - 1;
	sum_y /= j - 1;
	for (j = 1; j <= len; j++) {
		if (pp[j][i].all == 0)
			break;
		ps[j][i].other.x = sum_x;
		ps[j][i].other.y = sum_y;
		pr[j][i].other.x = sum_x;
		pr[j][i].other.y = sum_y;
	}
	return TRUE;
}
static void PointDelay(void)
{
	int i, j;

	for (i = 0; i < POINT_MAX; i++) {
		if (report_delay == 0 && delay_key == 0) {
			point_delay[i].all = 0;
			if (pp[0][i].all)
				point_delay[i].other.able = 1;
			if (pr[0][i].all == 0)
				point_delay[i].other.mask = 0;
			continue;
		}
		if (pp[0][i].all != 0 && point_delay[i].other.init == 0 &&
		    point_delay[i].other.able == 0) {
			if (point_num == 0)
				continue;
			if (delay_key && pp[0][i].other.key) {
				point_delay[i].other.delay =
					(delay_key >>
					 3 * ((point_num > 10 ? 10
							      : point_num) -
					      1)) &
					0x7;
				point_delay[i].other.report = 0;
				point_delay[i].other.dele = 0;
			} else {
				point_delay[i].other.delay =
					(report_delay >>
					 3 * ((point_num > 10 ? 10
							      : point_num) -
					      1)) &
					0x7;
				point_delay[i].other.report =
					(report_ahead >>
					 3 * ((point_num > 10 ? 10
							      : point_num) -
					      1)) &
					0x7;
				point_delay[i].other.dele =
					(report_delete >>
					 3 * ((point_num > 10 ? 10
							      : point_num) -
					      1)) &
					0x7;
				if (point_delay[i].other.report >
				    point_delay[i].other.delay)
					point_delay[i].other.report =
						point_delay[i].other.delay;
				point_delay[i].other.report =
					point_delay[i].other.delay -
					point_delay[i].other.report;
				if (point_delay[i].other.dele >
				    point_delay[i].other.report)
					point_delay[i].other.dele =
						point_delay[i].other.report;
				point_delay[i].other.dele =
					point_delay[i].other.report -
					point_delay[i].other.dele;
			}
			point_delay[i].other.init = 1;
		}
		if (id_flag.other.first_avg && pp[0][i].all == 0 &&
		    pp[1][i].all != 0 && point_delay[i].other.able == 0 &&
		    point_delay[i].other.init != 0) {
			if (PointDelayAvg(i)) {
				point_delay[i].other.able = 1;
				point_delay[i].other.report = 1;
				point_delay[i].other.dele = 1;
			} else {
				point_delay[i].other.init = 0;
			}
		} else if (pp[0][i].all == 0) {
			point_delay[i].other.init = 0;
		}
		if (point_delay[i].other.able == 0 &&
		    point_delay[i].other.init != 0) {
			for (j = 0; j <= (int)point_delay[i].other.delay; j++) {
				if (pp[j][i].all == 0 ||
				    pp[j][i].other.fill != 0 ||
				    pp[j][i].other.able != 0)
					break;
			}
			if (j <= (int)point_delay[i].other.delay)
				continue;
			if (PointDelayAvg(i))
				point_delay[i].other.able = 1;
			else
				j = 0;
			if (id_flag.other.first_avg)
				point_delay[i].other.report =
					point_delay[i].other.dele;
		}
		if (pp[point_delay[i].other.dele][i].all == 0) {
			point_delay[i].other.able = 0;
			point_delay[i].other.mask = 0;
			continue;
		}
		if (point_delay[i].other.able == 0)
			continue;
		if (report_delete == 0 && point_delay[i].other.report) {
			if (PointDistance(
				    &pp[point_delay[i].other.report][i],
				    &pp[point_delay[i].other.report - 1][i]) <
			    3 * 3) {
				point_delay[i].other.report--;
				if (point_delay[i].other.dele)
					point_delay[i].other.dele--;
			}
		}
	}
}

static unsigned int PointMOne(unsigned int x0, unsigned int x1)
{
	int e1, e2;

	e1 = (edge_start >> 24) & 0xff;
	e2 = (edge_start >> 16) & 0xff;
	if (e1 == 0)
		e1 = 18;
	if (e2 == 0)
		e2 = 24;
	if (x1 >= x0)
		return 0;
	if (x1 < (edge_start & 0xff) && x1 * e1 / 16 < x0)
		return 1;
	else if (x1 < (edge_start & 0xff) * 2 && x1 * e2 / 16 < x0)
		return 1;
	return 0;
}

static void PointMenu(void)
{
	unsigned int edge_dis;
	unsigned int edge_e;

	if (edge_start == 0)
		return;
	if (pp[0][0].all == 0 || pp[1][0].all == 0 ||
	    (pp[2][0].all != 0 && global_state.other.menu == 0) ||
	    pp[3][0].all != 0) {
		global_state.other.menu = FALSE;
		return;
	}
	if (point_delay[0].other.delay < 1 || point_delay[0].other.report < 1)
		return;
	edge_e = edge_start & 0xff;
	edge_dis = (edge_start & 0xff00) >> 8;
	edge_dis = edge_dis == 0 ? 8 * 8 : edge_dis * edge_dis;
	if (PointDistance(&pp[0][0], &pp[1][0]) >= edge_dis) {
		if (PointMOne(pp[0][0].other.x, pp[1][0].other.x))
			pr[1][0].other.x = 1;
		if (PointMOne(pp[0][0].other.y, pp[1][0].other.y))
			pr[1][0].other.y = 1;
		if (PointMOne(drv_num_nokey * 64 - pp[0][0].other.x,
			      drv_num_nokey * 64 - pp[1][0].other.x))
			pr[1][0].other.x = drv_num_nokey * 64 - 1;
		if (PointMOne(sen_num_nokey * 64 - pp[0][0].other.y,
			      sen_num_nokey * 64 - pp[1][0].other.y))
			pr[1][0].other.y = sen_num_nokey * 64 - 1;
	} else if (global_state.other.menu == 0) {
		if ((pp[0][0].other.x < edge_e && pp[1][0].other.x < edge_e) ||
		    (pp[0][0].other.y < edge_e && pp[1][0].other.y < edge_e) ||
		    (pp[0][0].other.x > drv_num_nokey * 64 - edge_e &&
		     pp[1][0].other.x > drv_num_nokey * 64 - edge_e) ||
		    (pp[0][0].other.y > sen_num_nokey * 64 - edge_e &&
		     pp[1][0].other.y > sen_num_nokey * 64 - edge_e)) {
			point_delay[0].other.able = FALSE;
			global_state.other.menu = TRUE;
		}
	}
}

static void FilterOne(int i, int *ps_c, int *pr_c, int denominator)
{
	int j;
	int x = 0, y = 0;

	pr[0][i].all = ps[0][i].all;
	if (pr[0][i].all == 0)
		return;
	if (denominator <= 0)
		return;
	for (j = 0; j < 8; j++) {
		x += (int)pr[j][i].other.x * (int)pr_c[j] +
		     (int)ps[j][i].other.x * (int)ps_c[j];
		y += (int)pr[j][i].other.y * (int)pr_c[j] +
		     (int)ps[j][i].other.y * (int)ps_c[j];
	}
	x = (x + denominator / 2) / denominator;
	y = (y + denominator / 2) / denominator;
	if (x < 0)
		x = 0;
	if (x > 0xffff)
		x = 0xffff;
	if (y < 0)
		y = 0;
	if (y > 0xfff)
		y = 0xfff;
	pr[0][i].other.x = x;
	pr[0][i].other.y = y;
}

static unsigned int FilterSpeed(int i)
{
	return (Sqrt(PointDistance(&ps[0][i], &ps[1][i])) +
		Sqrt(PointDistance(&ps[1][i], &ps[2][i]))) /
	       2;
}

static int MedianSpeedOver(int id, int deep)
{
	int i;
	unsigned int dis;
	int speed_over = 0;

	deep = deep / 2 - 1;
	if (deep < 0 || deep > 3)
		return TRUE;
	dis = median_dis[deep] * median_dis[deep];
	for (i = 0; i <= deep && i < POINT_DEEP; i++) {
		if (PointDistance(&ps[i][id], &ps[i + 1][id]) > dis)
			speed_over++;
	}
	if (speed_over >= 2)
		return TRUE;
	return FALSE;
}

static void PointMedian(void)
{
	int i, j;
	int deep;
	int buf_x[PS_DEEP], buf_y[PS_DEEP];

	for (i = 0; i < POINT_MAX; i++) {
		if (filter_deep[i] < 3)
			deep = 3;
		else
			deep = filter_deep[i] + 2;
		if (deep >= PS_DEEP)
			deep = PS_DEEP - 1;
		deep |= 1;
		for (; deep >= 3; deep -= 2) {
			if (MedianSpeedOver(i, deep))
				continue;
			for (j = 0; j < deep; j++) {
				buf_x[j] = ps[j][i].other.x;
				buf_y[j] = ps[j][i].other.y;
			}
			SortBubble(buf_x, deep);
			SortBubble(buf_y, deep);
			pr[0][i].other.x = buf_x[deep / 2];
			pr[0][i].other.y = buf_y[deep / 2];
			break;
		}
		filter_deep[i] = deep;
	}
}

static void PointFilter(void)
{
	int i, j;
	int speed_now;
	int filter_speed[6];
	int ps_c[8];
	int pr_c[8];

	for (i = 0; i < POINT_MAX; i++)
		pr[0][i].all = ps[0][i].all;

	for (i = 0; i < POINT_MAX; i++) {
		if (pr[0][i].all != 0 && pr[1][i].all == 0) {
			for (j = 1; j < PR_DEEP; j++)
				pr[j][i].all = ps[0][i].all;
			for (j = 1; j < PS_DEEP; j++)
				ps[j][i].all = ps[0][i].all;
		}
	}
	if (filter_able >= 0 && filter_able <= 1)
		return;
	if (filter_able > 1) {
		for (i = 0; i < 8; i++) {
			ps_c[i] = (filter_coe[i / 4] >> ((i % 4) * 8)) & 0xff;
			pr_c[i] =
				(filter_coe[i / 4 + 2] >> ((i % 4) * 8)) & 0xff;
			if (ps_c[i] >= 0x80)
				ps_c[i] |= 0xffffff00;
			if (pr_c[i] >= 0x80)
				pr_c[i] |= 0xffffff00;
		}
		for (i = 0; i < POINT_MAX; i++)
			FilterOne(i, ps_c, pr_c, filter_able);

	} else if (filter_able == -1) {
		PointMedian();
	} else if (filter_able < 0) {
		for (i = 0; i < 4; i++)
			filter_speed[i + 1] = median_dis[i];
		filter_speed[0] = median_dis[0] * 2 - median_dis[1];
		filter_speed[5] = median_dis[3] / 2;
		for (i = 0; i < POINT_MAX; i++) {
			if (pr[0][i].all == 0) {
				filter_deep[i] = 0;
				continue;
			}
			speed_now = FilterSpeed(i);
			if (filter_deep[i] > 0 &&
			    speed_now > filter_speed[filter_deep[i] + 1 - 2])
				filter_deep[i]--;
			else if (filter_deep[i] < 3 &&
				 speed_now <
					 filter_speed[filter_deep[i] + 1 + 2])
				filter_deep[i]++;

			FilterOne(i, ps_coe[filter_deep[i]],
				  pr_coe[filter_deep[i]], 0 - filter_able);
		}
	}
}

static unsigned int KeyMap(int *drv, int *sen)
{
	struct KEY_TYPE_RANGE {
		unsigned int up_down, left_right;
		unsigned int coor;
	};
	struct KEY_TYPE_RANGE *key_range =
		(struct KEY_TYPE_RANGE *)key_range_array;
	int i;

	for (i = 0; i < 8; i++) {
		if ((unsigned int)*drv >= (key_range[i].up_down >> 16) &&
		    (unsigned int)*drv <= (key_range[i].up_down & 0xffff) &&
		    (unsigned int)*sen >= (key_range[i].left_right >> 16) &&
		    (unsigned int)*sen <= (key_range[i].left_right & 0xffff)) {
			*sen = key_range[i].coor >> 16;
			*drv = key_range[i].coor & 0xffff;
			return key_range[i].coor;
		}
	}
	return 0;
}

static unsigned int ScreenResolution(union gsl_POINT_TYPE *p)
{
	int x, y;

	x = p->other.x;
	y = p->other.y;
	if (p->other.key == FALSE) {
		y = ((y - match_y[1]) * match_y[0] + 2048) / 4096;
		x = ((x - match_x[1]) * match_x[0] + 2048) / 4096;
	}
	y = y * (int)screen_y_max / ((int)sen_num_nokey * 64);
	x = x * (int)screen_x_max / ((int)drv_num_nokey * 64);
	if (p->other.key == FALSE) {
		if (id_flag.other.ignore_pri == 0) {
			if (ignore_y[0] != 0 || ignore_y[1] != 0) {
				if (y < ignore_y[0])
					return 0;
				if (ignore_y[1] <= screen_y_max / 2 &&
				    y > screen_y_max - ignore_y[1])
					return 0;
				if (ignore_y[1] >= screen_y_max / 2 &&
				    y > ignore_y[1])
					return 0;
			}
			if (ignore_x[0] != 0 || ignore_x[1] != 0) {
				if (x < ignore_x[0])
					return 0;
				if (ignore_x[1] <= screen_x_max / 2 &&
				    x > screen_x_max - ignore_x[1])
					return 0;
				if (ignore_x[1] >= screen_x_max / 2 &&
				    x > ignore_x[1])
					return 0;
			}
		}
		if (y <= (int)edge_cut[2])
			y = (int)edge_cut[2] + 1;
		if (y >= screen_y_max - (int)edge_cut[3])
			y = screen_y_max - (int)edge_cut[3] - 1;
		if (x <= (int)edge_cut[0])
			x = (int)edge_cut[0] + 1;
		if (x >= screen_x_max - (int)edge_cut[1])
			x = screen_x_max - (int)edge_cut[1] - 1;
		if (global_flag.other.opposite_x)
			y = screen_y_max - y;
		if (global_flag.other.opposite_y)
			x = screen_x_max - x;
		if (global_flag.other.opposite_xy) {
			y ^= x;
			x ^= y;
			y ^= x;
		}
	} else {
		if (y < 0)
			y = 0;
		if (x < 0)
			x = 0;
		if ((key_map_able & 0x1) != FALSE && KeyMap(&x, &y) == 0)
			return 0;
	}
	return ((y << 16) & 0x0fff0000) + (x & 0x0000ffff);
}

static void PointReport(struct gsl_touch_info *cinfo)
{
	int i;
	unsigned int data[POINT_MAX];
	unsigned int dp[POINT_MAX];
	int num = 0;

	if (point_num > point_num_max &&
	    global_flag.other.over_report_mask != 0) {
		point_num = 0;
		cinfo->finger_num = 0;
		prec_id.all = 0;
		return;
	}
	for (i = 0; i < POINT_MAX; i++)
		data[i] = dp[i] = 0;
	num = 0;
	if (global_flag.other.id_over) {
		for (i = 0; i < POINT_MAX && num < point_num_max; i++) {
			if (point_delay[i].other.mask ||
			    point_delay[i].other.able == 0)
				continue;
			if (point_delay[i].other.report >= PR_DEEP - 1)
				continue;
			if (pr[point_delay[i].other.report + 1][i].other.able ==
			    0)
				continue;
			if (pr[point_delay[i].other.report][i].all) {
				pr[point_delay[i].other.report][i].other.able =
					1;
				data[i] = ScreenResolution(
					&pr[point_delay[i].other.report][i]);
				if (data[i]) {
					dp[i] = pressure_report[i];
					data[i] |= (i + 1) << 28;
					num++;
				}
			}
		}
		for (i = 0; i < POINT_MAX && num < point_num_max; i++) {
			if (point_delay[i].other.mask ||
			    point_delay[i].other.able == 0)
				continue;
			if (point_delay[i].other.report >= PR_DEEP)
				continue;
			if (pr[point_delay[i].other.report][i].all == 0)
				continue;
			if (pr[point_delay[i].other.report][i].other.able ==
			    0) {
				pr[point_delay[i].other.report][i].other.able =
					1;
				data[i] = ScreenResolution(
					&pr[point_delay[i].other.report][i]);
				if (data[i]) {
					dp[i] = pressure_report[i];
					data[i] |= (i + 1) << 28;
					num++;
				}
			}
		}
	} else {
		num = 0;
		for (i = 0; i < point_num_max && i < POINT_MAX; i++) {
			if (point_delay[i].other.mask ||
			    point_delay[i].other.able == 0)
				continue;
			if (point_delay[i].other.report >= PR_DEEP)
				continue;
			data[num] = ScreenResolution(
				&pr[point_delay[i].other.report][i]);
			if (data[num]) {
				dp[num] = pressure_report[i];
				data[num++] |= (i + 1) << 28;
			}
		}
	}
	num = 0;
	for (i = 0; i < POINT_MAX; i++) {
		if (data[i] == 0)
			continue;
		point_now[num].all = data[i];
		cinfo->x[num] = (data[i] >> 16) & 0xfff;
		cinfo->y[num] = data[i] & 0xfff;
		cinfo->id[num] = data[i] >> 28;
		pressure_now[num] = dp[i];
		num++;
	}
	for (i = num; i < POINT_MAX; i++) {
		point_now[i].all = 0;
		pressure_now[i] = 0;
	}
	point_num = num;
	cinfo->finger_num = point_num;
	if (id_flag.other.id_prec_able == FALSE)
		return;
	if (prec_id.all == 0 && point_num == 1) {
		if ((point_now[0].all >> 28) > 1)
			prec_id.other.id = (point_now[0].all >> 28);
		else
			prec_id.other.id = 0xff;
	}
	if (prec_id.other.id != 0 && prec_id.other.id != 0xff) {
		for (i = 0; i < point_num; i++) {
			if ((point_now[i].all >> 28) == 1) {
				point_now[i].all &= ~(0xf << 28);
				point_now[i].all |= prec_id.other.id << 28;
				cinfo->id[i] = prec_id.other.id;
			} else if ((point_now[i].all >> 28) ==
				   prec_id.other.id) {
				point_now[i].all &= ~(0xf << 28);
				point_now[i].all |= 1 << 28;
				cinfo->id[i] = 1;
			}
		}
	}
	if (point_num == 0)
		prec_id.all = 0;
	else
		prec_id.other.num = (unsigned char)point_num;
}

static void PointRound(void)
{
	int id, i;
	int x, y;
	int x0, y0;
	int dis, r[4], coe[4];
	struct STRETCH_TYPE {
		int range;
		int coe;
	};
	struct STRETCH_TYPE_ALL {
		struct STRETCH_TYPE up[4];
		struct STRETCH_TYPE down[4];
		struct STRETCH_TYPE left[4];
		struct STRETCH_TYPE right[4];
	}; /* stretch; */
	struct STRETCH_TYPE_ALL *stretch;
	int sac[4 * 4 * 2]; /* stretch_array_copy */
	int data[2];

	if (id_flag.other.round == 0 || id_flag.other.stretch_off)
		return;
	if (screen_x_max == 0 || screen_y_max == 0)
		return;
	id = 0;
	for (i = 0; i < 4 * 4 * 2; i++) {
		sac[i] = stretch_array[i];
		if (sac[i])
			id++;
	}
	if (id == 0)
		return;
	stretch = (struct STRETCH_TYPE_ALL *)sac;
	for (i = 0; i < 4; i++) {
		if (stretch->up[i].range)
			stretch->up[i].range = stretch->up[i].range *
					       sen_num_nokey * drv_num_nokey *
					       64 / screen_x_max;
		if (stretch->down[i].range)
			stretch->down[i].range = stretch->down[i].range *
						 sen_num_nokey * drv_num_nokey *
						 64 / screen_x_max;
		if (stretch->left[i].range)
			stretch->left[i].range = stretch->left[i].range *
						 sen_num_nokey * drv_num_nokey *
						 64 / screen_y_max;
		if (stretch->right[i].range)
			stretch->right[i].range =
				stretch->right[i].range * sen_num_nokey *
				drv_num_nokey * 64 / screen_y_max;
	}

	x0 = 64 * sen_num_nokey * drv_num_nokey / 2;
	y0 = x0;
	for (id = 0; id < POINT_MAX; id++) {
		if (point_now[id].all == 0 || point_now[id].other.key != 0)
			continue;
		x = point_now[id].other.x * sen_num_nokey;
		y = point_now[id].other.y * drv_num_nokey;
		dis = Sqrt((x - x0) * (x - x0) + (y - y0) * (y - y0));

		for (i = 0; i < 4; i++) {
			r[i] = 0;
			coe[i] = 0;
			if (x < x0) {
				r[i] += (x0 - x) * stretch->up[i].range / dis *
					(x0 - x) * stretch->up[i].range / dis;
				coe[i] += (x0 - x) * stretch->up[i].coe / dis *
					  (x0 - x) * stretch->up[i].coe / dis;
			}
			if (x > x0) {
				r[i] += (x - x0) * stretch->down[i].range /
					dis * (x - x0) *
					stretch->down[i].range / dis;
				coe[i] += (x - x0) * stretch->down[i].coe /
					  dis * (x - x0) *
					  stretch->down[i].coe / dis;
			}
			if (y < y0) {
				r[i] += (y0 - y) * stretch->left[i].range /
					dis * (y0 - y) *
					stretch->left[i].range / dis;
				coe[i] += (y0 - y) * stretch->left[i].coe /
					  dis * (y0 - y) *
					  stretch->left[i].coe / dis;
			}
			if (y > y0) {
				r[i] += (y - y0) * stretch->right[i].range /
					dis * (y - y0) *
					stretch->right[i].range / dis;
				coe[i] += (y - y0) * stretch->right[i].coe /
					  dis * (y - y0) *
					  stretch->right[i].coe / dis;
			}
			r[i] = Sqrt(r[i]);
			coe[i] = Sqrt(coe[i]);
		}
		data[0] = 0;
		data[1] = dis;
		for (i = 3; i >= 0; i--) {
			if (r[i] == 0 || coe[i] <= 1)
				continue;
			if (data[1] > r[i]) {
				data[0] += (data[1] - r[i]) * coe[i] / 128;
				data[1] = r[i];
			}
		}
		data[0] += data[1];
		x = (x - x0) * data[0] / dis + x0;
		y = (y - y0) * data[0] / dis + y0;

		for (i = 1; i < 4; i++) {
			if (r[i] == 0)
				break;
			if (coe[i] > 1)
				continue;
			dis = Sqrt((x - x0) * (x - x0) + (y - y0) * (y - y0));
			if (dis <= r[i] || dis <= 0)
				break;
			x = (x - x0) * r[i] / dis + x0;
			y = (y - y0) * r[i] / dis + y0;
		}
		x /= (int)sen_num_nokey;
		if (x <= 0)
			x = 1;
		if (x > 0xfff)
			x = 0xfff;
		point_now[id].other.x = x;
		y /= (int)drv_num_nokey;
		if (y <= 0)
			y = 1;
		if (y > 0xfff)
			y = 0xfff;
		point_now[id].other.y = y;
	}
}

static void PointEdge(void)
{
	struct STRETCH_TYPE {
		int range;
		int coe;
	};
	struct STRETCH_TYPE_ALL {
		struct STRETCH_TYPE up[4];
		struct STRETCH_TYPE down[4];
		struct STRETCH_TYPE left[4];
		struct STRETCH_TYPE right[4];
	};
	struct STRETCH_TYPE_ALL *stretch;
	int i, id;
	int data[2];
	int x, y;
	int sac[4 * 4 * 2];

	if (id_flag.other.round || id_flag.other.stretch_off)
		return;
	if (screen_x_max == 0 || screen_y_max == 0)
		return;
	id = 0;
	for (i = 0; i < 4 * 4 * 2; i++) {
		if (global_state.other.active)
			sac[i] = stretch_active[i];
		else
			sac[i] = stretch_array[i];
		if (sac[i])
			id++;
	}
	if (id == 0)
		return;
	stretch = (struct STRETCH_TYPE_ALL *)sac;
	for (i = 0; i < 4; i++) {
		if (id_flag.other.screen_core)
			break;
		if (stretch->right[i].range > screen_y_max * 64 / 128 ||
		    stretch->down[i].range > screen_x_max * 64 / 128 ||
		    id_flag.other.screen_real) {
			for (i = 0; i < 4; i++) {
				if (stretch->up[i].range)
					stretch->up[i].range =
						stretch->up[i].range *
						drv_num_nokey * 64 /
						screen_x_max;
				if (stretch->down[i].range)
					stretch->down[i].range =
						(screen_x_max -
						 stretch->down[i].range) *
						drv_num_nokey * 64 /
						screen_x_max;
				if (stretch->left[i].range)
					stretch->left[i].range =
						stretch->left[i].range *
						sen_num_nokey * 64 /
						screen_y_max;
				if (stretch->right[i].range)
					stretch->right[i].range =
						(screen_y_max -
						 stretch->right[i].range) *
						sen_num_nokey * 64 /
						screen_y_max;
			}
			break;
		}
	}
	for (id = 0; id < POINT_MAX; id++) {
		if (point_now[id].all == 0 || point_now[id].other.key != 0)
			continue;
		x = point_now[id].other.x;
		y = point_now[id].other.y;

		data[0] = 0;
		data[1] = y;
		for (i = 0; i < 4; i++) {
			if (stretch->left[i].range == 0)
				break;
			if (data[1] < stretch->left[i].range) {
				data[0] += (stretch->left[i].range - data[1]) *
					   stretch->left[i].coe / 128;
				data[1] = stretch->left[i].range;
			}
		}
		y = data[1] - data[0];
		if (y <= 0)
			y = 1;
		if (y >= (int)sen_num_nokey * 64)
			y = sen_num_nokey * 64 - 1;

		data[0] = 0;
		data[1] = sen_num_nokey * 64 - y;
		for (i = 0; i < 4; i++) {
			if (stretch->right[i].range == 0)
				break;
			if (data[1] < stretch->right[i].range) {
				data[0] += (stretch->right[i].range - data[1]) *
					   stretch->right[i].coe / 128;
				data[1] = stretch->right[i].range;
			}
		}
		y = sen_num_nokey * 64 - (data[1] - data[0]);
		if (y <= 0)
			y = 1;
		if (y >= (int)sen_num_nokey * 64)
			y = sen_num_nokey * 64 - 1;

		data[0] = 0;
		data[1] = x;
		for (i = 0; i < 4; i++) {
			if (stretch->up[i].range == 0)
				break;
			if (data[1] < stretch->up[i].range) {
				data[0] += (stretch->up[i].range - data[1]) *
					   stretch->up[i].coe / 128;
				data[1] = stretch->up[i].range;
			}
		}
		x = data[1] - data[0];
		if (x <= 0)
			x = 1;
		if (x >= (int)drv_num_nokey * 64)
			x = drv_num_nokey * 64 - 1;

		data[0] = 0;
		data[1] = drv_num_nokey * 64 - x;
		for (i = 0; i < 4; i++) {
			if (stretch->down[i].range == 0)
				break;
			if (data[1] < stretch->down[i].range) {
				data[0] += (stretch->down[i].range - data[1]) *
					   stretch->down[i].coe / 128;
				data[1] = stretch->down[i].range;
			}
		}
		x = drv_num_nokey * 64 - (data[1] - data[0]);
		if (x <= 0)
			x = 1;
		if (x >= (int)drv_num_nokey * 64)
			x = drv_num_nokey * 64 - 1;

		point_now[id].other.x = x;
		point_now[id].other.y = y;
	}
}

static void PointStretch_for(int *dc_p, int *ds_p)
{
	static int save_dr[POINT_MAX], save_dn[POINT_MAX];
	int i, j;
	int dn;
	int dr;
	int *dc, *ds;
	int len = 8;

	dc = dc_p;
	ds = ds_p;
	for (i = 0; i < POINT_MAX; i++) {
		if (ps[1][i].all == 0) {
			for (j = 1; j < PS_DEEP; j++)
				ps[j][i].all = ps[0][i].all;
			save_dr[i] = 128;
			save_dn[i] = 0;
			continue;
		}
		if (id_flag.other.first_avg && point_delay[i].other.able == 0)
			continue;
		if ((point_shake & (0x1 << i)) == 0)
			continue;
		if (dc[len] == 3) /* dc == 2 */ {
			dn = pp[0][i].other.x > ps[1][i].other.x
				     ? pp[0][i].other.x - ps[1][i].other.x
				     : ps[1][i].other.x - pp[0][i].other.x;
			if (dn < ds[0]) {
				for (j = 0; j <= len; j++) {
					if (j == len || dn == 0) {
						ps[0][i].other.x =
							ps[1][i].other.x;
						break;
					} else if (ds[j] > dn &&
						   dn >= ds[j + 1]) {
						dr = dc[j + 1] +
						     ((dn - ds[j + 1]) *
						      (dc[j] - dc[j + 1])) /
							     (ds[j] -
							      ds[j + 1]);
						ps[0][i].other.x =
							(int)ps[1][i].other.x +
							(((int)pp[0][i]
								  .other.x -
							  (int)ps[1][i]
								  .other.x) *
								 dr +
							 64) / 128;
						break;
					}
				}
			}
			dn = pp[0][i].other.y > ps[1][i].other.y
				     ? pp[0][i].other.y - ps[1][i].other.y
				     : ps[1][i].other.y - pp[0][i].other.y;
			if (dn < ds[0]) {
				for (j = 0; j <= len; j++) {
					if (j == len || dn == 0) {
						ps[0][i].other.y =
							ps[1][i].other.y;
						break;
					} else if (ds[j] > dn &&
						   dn >= ds[j + 1]) {
						dr = dc[j + 1] +
						     ((dn - ds[j + 1]) *
						      (dc[j] - dc[j + 1])) /
							     (ds[j] -
							      ds[j + 1]);
						ps[0][i].other.y =
							(int)ps[1][i].other.y +
							(((int)pp[0][i]
								  .other.y -
							  (int)ps[1][i]
								  .other.y) *
								 dr +
							 64) / 128;
						break;
					}
				}
			}
		} else {
			dn = PointDistance(&pp[0][i], &ps[1][i]);
			dn = Sqrt(dn);
			if (dn >= ds[0])
				continue;

			if (dn < save_dn[i]) {
				dr = save_dr[i];
				save_dn[i] = dn;
				ps[0][i].other.x = (int)ps[1][i].other.x +
						   (((int)pp[0][i].other.x -
						     (int)ps[1][i].other.x) *
						    dr) / 128;
				ps[0][i].other.y = (int)ps[1][i].other.y +
						   (((int)pp[0][i].other.y -
						     (int)ps[1][i].other.y) *
						    dr) / 128;
				continue;
			}
			for (j = 0; j <= len; j++) {
				if (j == len || dn == 0) {
					ps[0][i].other.x = ps[1][i].other.x;
					ps[0][i].other.y = ps[1][i].other.y;
					break;
				} else if (ds[j] > dn && dn >= ds[j + 1]) {
					dr = dc[j + 1] +
					     ((dn - ds[j + 1]) *
					      (dc[j] - dc[j + 1])) /
						     (ds[j] - ds[j + 1]);
					save_dr[i] = dr;
					save_dn[i] = dn;
					ps[0][i].other.x =
						(int)ps[1][i].other.x +
						(((int)pp[0][i].other.x -
						  (int)ps[1][i].other.x) *
							 dr +
						 64) / 128;
					ps[0][i].other.y =
						(int)ps[1][i].other.y +
						(((int)pp[0][i].other.y -
						  (int)ps[1][i].other.y) *
							 dr +
						 64) / 128;
					break;
				}
			}
		}
	}
}

static void PointStretch(void)
{
	struct SHAKE_TYPE {
		int dis;
		int coe;
	};
	struct SHAKE_TYPE *shake_all = (struct SHAKE_TYPE *)shake_all_array;
	int i, j;
	int dn;
	int dr;
	int dc[9], ds[9];
	int len = 8;
	unsigned int temp;

	for (i = 0; i < POINT_MAX; i++)
		ps[0][i].all = pp[0][i].all;

	for (i = 0; i < POINT_MAX; i++) {
		if (pp[0][i].all == 0 || pp[0][i].other.key) {
			point_shake &= ~(0x1 << i);
			if (i == 0)
				point_edge.rate = 0;
			continue;
		}
		if (i == 0) {
			if (edge_first != 0 && ps[1][i].all == 0) {
				point_edge.coor.all = ps[0][i].all;
				if (point_edge.coor.other.x <
				    (unsigned int)((edge_first >> 24) & 0xff))
					point_edge.coor.other.x =
						((edge_first >> 24) & 0xff);
				if (point_edge.coor.other.x >
				    drv_num_nokey * 64 -
					    ((edge_first >> 16) & 0xff))
					point_edge.coor.other.x =
						drv_num_nokey * 64 -
						((edge_first >> 16) & 0xff);
				if (point_edge.coor.other.y <
				    (unsigned int)((edge_first >> 8) & 0xff))
					point_edge.coor.other.y =
						((edge_first >> 8) & 0xff);
				if (point_edge.coor.other.y >
				    sen_num_nokey * 64 -
					    ((edge_first >> 0) & 0xff))
					point_edge.coor.other.y =
						sen_num_nokey * 64 -
						((edge_first >> 0) & 0xff);
				if (point_edge.coor.all != ps[0][i].all) {
					point_edge.dis = PointDistance(
						&ps[0][i], &point_edge.coor);
					if (point_edge.dis)
						point_edge.rate = 0x1000;
				}
			}
			if (point_edge.rate != 0 && point_edge.dis != 0) {
				temp = PointDistance(&ps[0][i],
						     &point_edge.coor);
				if (temp >=
				    point_edge.dis * edge_first_coe / 0x80) {
					point_edge.rate = 0;
				} else if (temp > point_edge.dis) {
					temp = (point_edge.dis *
							edge_first_coe / 0x80 -
						temp) *
					       0x1000 / point_edge.dis;
					if (temp < point_edge.rate)
						point_edge.rate = temp;
				}
				ps[0][i].other.x =
					point_edge.coor.other.x +
					(ps[0][i].other.x -
					 point_edge.coor.other.x) *
						(0x1000 - point_edge.rate) /
						0x1000;
				ps[0][i].other.y =
					point_edge.coor.other.y +
					(ps[0][i].other.y -
					 point_edge.coor.other.y) *
						(0x1000 - point_edge.rate) /
						0x1000;
			}
		}
		if (ps[1][i].all == 0) {
			continue;
		} else if (id_flag.other.first_avg &&
			   (point_shake & (0x1 << i)) == 0 && pp[0][i].all &&
			   point_delay[i].other.able == 0 && shake_min != 0) {
			dn = 0;
			for (j = 1; j < PP_DEEP /* && j < PS_DEEP*/; j++) {
				if (pp[j][i].all == 0)
					break;
			}
			j--;
			dn = PointDistance(&ps[0][i], &ps[j][i]);
			if (PointDistance(&ps[0][i], &ps[j][i]) >=
			    (unsigned int)shake_min * 4) {
				point_delay[i].other.init = 1;
				point_delay[i].other.able = 1;
				point_delay[i].other.report = 1;
				point_delay[i].other.dele = 1;
			}
		} else if ((point_shake & (0x1 << i)) == 0) {
			if (PointDistance(&ps[0][i], &ps[1][i]) <
			    (unsigned int)shake_min) {
				if (point_delay[i].other.able)
					ps[0][i].all = ps[1][i].all;
				else {
					for (j = 1; j < PS_DEEP; j++)
						ps[j][i].all = ps[0][i].all;
					for (j = 0; j < PR_DEEP; j++)
						pr[j][i].all = ps[0][i].all;
				}
				continue;
			} else
				point_shake |= (0x1 << i);
		}
	}
	for (i = 0; i < len; i++) {
		if (shake_all[i].dis == 0) {
			len = i;
			break;
		}
	}
	if (len == 1) {
		ds[0] = shake_all[0].dis;
		dc[0] = (shake_all[0].coe * 100 + 64) / 128;
		for (i = 0; i < POINT_MAX; i++) {
			if (ps[1][i].all == 0) {
				for (j = 1; j < PS_DEEP; j++)
					ps[j][i].all = ps[0][i].all;
				continue;
			}
			if ((point_shake & (0x1 << i)) == 0)
				continue;
			dn = PointDistance(&pp[0][i], &ps[1][i]);
			dn = Sqrt(dn);
			dr = dn > ds[0] ? dn - ds[0] : 0;
			temp = ps[0][i].all;
			if (dn == 0 || dr == 0) {
				ps[0][i].other.x = ps[1][i].other.x;
				ps[0][i].other.y = ps[1][i].other.y;
			} else {
				ps[0][i].other.x = (int)ps[1][i].other.x +
						   ((int)pp[0][i].other.x -
						    (int)ps[1][i].other.x) *
							   dr / dn;
				ps[0][i].other.y = (int)ps[1][i].other.y +
						   ((int)pp[0][i].other.y -
						    (int)ps[1][i].other.y) *
							   dr / dn;
			}
			if (dc[0] > 0) {
				if (ps[0][i].all == ps[1][i].all &&
				    temp != ps[0][i].all) {
					ps[0][i].all = temp;
					point_decimal[i].other.x +=
						ps[0][i].other.x -
						ps[1][i].other.x;
					point_decimal[i].other.y +=
						ps[0][i].other.y -
						ps[1][i].other.y;
					ps[0][i].other.x = ps[1][i].other.x;
					ps[0][i].other.y = ps[1][i].other.y;
					if (point_decimal[i].other.x > dc[0] &&
					    ps[1][i].other.x < 0xffff) {
						ps[0][i].other.x += 1;
						point_decimal[i].other.x = 0;
					}
					if (point_decimal[i].other.x < -dc[0] &&
					    ps[1][i].other.x > 0) {
						ps[0][i].other.x -= 1;
						point_decimal[i].other.x = 0;
					}
					if (point_decimal[i].other.y > dc[0] &&
					    ps[1][i].other.y < 0xfff) {
						ps[0][i].other.y += 1;
						point_decimal[i].other.y = 0;
					}
					if (point_decimal[i].other.y < -dc[0] &&
					    ps[1][i].other.y > 0) {
						ps[0][i].other.y -= 1;
						point_decimal[i].other.y = 0;
					}
				} else {
					point_decimal[i].other.x = 0;
					point_decimal[i].other.y = 0;
				}
			}
		}

	} else if (len >= 2) {
		temp = 0;
		for (i = 0; i < POINT_MAX; i++)
			if (pp[0][i].all)
				temp++;
		if (temp > 5)
			temp = 5;
		for (i = 0; i < 8 && i < len; i++) {
			if (stretch_mult)
				ds[i + 1] = shake_all[i].dis *
					    (stretch_mult *
						     (temp > 1 ? temp - 1 : 0) +
					     0x80) /
					    0x80;
			else
				ds[i + 1] = shake_all[i].dis;
			dc[i + 1] =
				shake_all[i]
					.coe; /* ;ds[i+1] * shake_all[i].coe; */
		}
		if (shake_all[0].coe >= 128 ||
		    shake_all[0].coe <= shake_all[1].coe) {
			ds[0] = ds[1];
			dc[0] = dc[1];
		} else {
			ds[0] = ds[1] +
				(128 - shake_all[0].coe) * (ds[1] - ds[2]) /
					(shake_all[0].coe - shake_all[1].coe);
			dc[0] = 128;
		}
		PointStretch_for(dc, ds);
	} else {
		return;
	}
}

static void ResetMask(void)
{
	if (reset_mask_send)
		reset_mask_send = 0;

	if (global_state.other.mask)
		return;
	if (reset_mask_dis == 0 || reset_mask_type == 0)
		return;
	if (reset_mask_max == 0xfffffff1) {
		if (point_num == 0)
			reset_mask_max = 0xf0000000 + 1;
		return;
	}
	if (reset_mask_max > 0xf0000000) {
		reset_mask_max--;
		if (reset_mask_max == 0xf0000000) {
			reset_mask_send = reset_mask_type;
			global_state.other.mask = 1;
		}
		return;
	}
	if (point_num > 1 || pp[0][0].all == 0) {
		reset_mask_count = 0;
		reset_mask_max = 0;
		reset_mask_count = 0;
		return;
	}
	reset_mask_count++;
	if (reset_mask_max == 0)
		reset_mask_max = pp[0][0].all;
	else if (PointDistance((union gsl_POINT_TYPE *)(&reset_mask_max),
			       pp[0]) >
			 (((unsigned int)reset_mask_dis) & 0xffffff) &&
		 reset_mask_count > (((unsigned int)reset_mask_dis) >> 24))
		reset_mask_max = 0xfffffff1;
}

static int ConfigCoorMulti(unsigned int data[])
{
	int i, j;
	int n = 0;

	for (i = 0; i < 4; i++) {
		if (data[247 + i] != 0) {
			if ((data[247 + i] & 63) == 0 &&
			    (data[247 + i] >> 16) < 4)
				n++;
			else
				return FALSE;
		}
		if (data[251 + i] != 0) {
			if ((data[251 + i] & 63) == 0 &&
			    (data[251 + i] >> 16) < 4)
				n++;
			else
				return FALSE;
		}
	}
	if (n == 0 || n > 4)
		return FALSE;
	for (j = 0; j < n; j++) {
		for (i = 0; i < 64; i++) {
			if (data[256 + j * 64 + i] >= 64)
				return FALSE;
			if (i) {
				if (data[256 + j * 64 + i] <
				    data[256 + j * 64 + i - 1])
					return FALSE;
			}
		}
	}
	return TRUE;
}

static int ConfigFilter(unsigned int data[])
{
	int i;
	unsigned int ps_c[8];
	unsigned int pr_c[8];
	unsigned int sum = 0;
	/* if(data[242]>1 && (data[255]>=0 && data[255]<=256)) */
	if (data[242] > 1 && (data[255] <= 256)) {
		for (i = 0; i < 8; i++) {
			ps_c[i] = (data[243 + i / 4] >> ((i % 4) * 8)) & 0xff;
			pr_c[i] =
				(data[243 + i / 4 + 2] >> ((i % 4) * 8)) & 0xff;
			if (ps_c[i] >= 0x80)
				ps_c[i] |= 0xffffff00;
			if (pr_c[i] >= 0x80)
				pr_c[i] |= 0xffffff00;
			sum += ps_c[i];
			sum += pr_c[i];
		}
		if (sum == data[242] || sum + data[242] == 0)
			return TRUE;
	}
	return FALSE;
}

static int ConfigKeyMap(unsigned int data[])
{
	int i;

	if (data[217] != 1)
		return FALSE;
	for (i = 0; i < 8; i++) {
		if (data[218 + 2] == 0)
			return FALSE;
		if ((data[218 + i * 3 + 0] >> 16) >
		    (data[218 + i * 3 + 0] & 0xffff))
			return FALSE;
		if ((data[218 + i * 3 + 1] >> 16) >
		    (data[218 + i * 3 + 1] & 0xffff))
			return FALSE;
	}
	return TRUE;
}

static int DiagonalDistance(union gsl_POINT_TYPE *p, int type)
{
	int divisor, square;

	divisor = ((int)sen_num_nokey * (int)sen_num_nokey +
		   (int)drv_num_nokey * (int)drv_num_nokey) /
		  16;
	if (divisor == 0)
		divisor = 1;
	if (type == 0)
		square = ((int)sen_num_nokey * (int)(p->other.x) -
			  (int)drv_num_nokey * (int)(p->other.y)) /
			 4;
	else
		square = ((int)sen_num_nokey * (int)(p->other.x) +
			  (int)drv_num_nokey * (int)(p->other.y) -
			  (int)sen_num_nokey * (int)drv_num_nokey * 64) /
			 4;
	return square * square / divisor;
}

static void DiagonalCompress(union gsl_POINT_TYPE *p, int type, int dis,
			     int dis_max)
{
	int x, y;
	int tx, ty;
	int cp_ceof;

	if (dis_max == 0)
		return;
	if (dis > dis_max)
		cp_ceof = (dis - dis_max) * 128 / (3 * dis_max) + 128;
	else
		cp_ceof = 128;
	if (cp_ceof > 256)
		cp_ceof = 256;
	x = p->other.x;
	y = p->other.y;
	if (type)
		y = (int)sen_num_nokey * 64 - y;
	x *= (int)sen_num_nokey;
	y *= (int)drv_num_nokey;
	tx = x;
	ty = y;
	x = ((tx + ty) + (tx - ty) * cp_ceof / 256) / 2;
	y = ((tx + ty) + (ty - tx) * cp_ceof / 256) / 2;
	x /= (int)sen_num_nokey;
	y /= (int)drv_num_nokey;
	if (type)
		y = sen_num_nokey * 64 - y;
	if (x < 1)
		x = 1;
	if (y < 1)
		y = 1;
	if (x >= (int)drv_num_nokey * 64)
		x = drv_num_nokey * 64 - 1;
	if (y >= (int)sen_num_nokey * 64)
		y = (int)sen_num_nokey * 64 - 1;
	p->other.x = x;
	p->other.y = y;
}

static void PointDiagonal(void)
{
	int i;
	int diagonal_size;
	int dis;
	unsigned int diagonal_start;

	if (diagonal == 0)
		return;
	diagonal_size = diagonal * diagonal;
	diagonal_start = diagonal * 3 / 2;
	for (i = 0; i < POINT_MAX; i++) {
		if (ps[0][i].all == 0 || ps[0][i].other.key != 0) {
			point_corner &= ~(0x3 << i * 2);
			continue;
		} else if ((point_corner & (0x3 << i * 2)) == 0) {
			if ((ps[0][i].other.x <= diagonal_start &&
			     ps[0][i].other.y <= diagonal_start) ||
			    (ps[0][i].other.x >=
				     drv_num_nokey * 64 - diagonal_start &&
			     ps[0][i].other.y >=
				     sen_num_nokey * 64 - diagonal_start))
				point_corner |= 0x2 << i * 2;
			else if ((ps[0][i].other.x <= diagonal_start &&
				  ps[0][i].other.y >= sen_num_nokey * 64 -
							      diagonal_start) ||
				 (ps[0][i].other.x >=
					  drv_num_nokey * 64 - diagonal_start &&
				  ps[0][i].other.y <= diagonal_start))
				point_corner |= 0x3 << i * 2;
			else
				point_corner |= 0x1 << i * 2;
		}
		if (point_corner & (0x2 << i * 2)) {
			dis = DiagonalDistance(&(ps[0][i]),
					       point_corner & (0x1 << i * 2));
			if (dis <= diagonal_size * 4) {
				DiagonalCompress(&(ps[0][i]),
						 point_corner & (0x1 << i * 2),
						 dis, diagonal_size);
			} else if (dis > diagonal_size * 4) {
				point_corner &= ~(0x3 << i * 2);
				point_corner |= 0x1 << i * 2;
			}
		}
	}
}

static int PointSlope(int i, int j)
{
	int x, y;

	x = pr[j][i].other.x - pr[j + 1][i].other.x;
	x = x * x;
	y = pr[j][i].other.y - pr[j + 1][i].other.y;
	y = y * y;
	if (x + y == 0)
		return -1;
	if (x > y)
		return x * 1024 / (x + y);
	else
		return y * 1024 / (x + y);
}

static void PointExtend(void)
{
	int i, j;
	int x, y;
	int t, t2;
	int extend_len = 5;

	if (point_extend == 0)
		return;
	for (i = 0; i < POINT_MAX; i++) {
		if (pr[0][i].other.fill == 0)
			continue;
		for (j = 0; j < extend_len; j++) {
			if (pr[j][i].all == 0)
				break;
		}
		if (j < extend_len)
			continue;
		if (PointDistance(&pr[1][i], &pr[2][i]) < 16 * 16)
			continue;
		t = PointSlope(i, 1);
		for (j = 2; j < extend_len - 1; j++) {
			t2 = PointSlope(i, j);
			if (t2 < 0 || t2 < t * (128 - point_extend) / 128 ||
			    t2 > t * (128 + point_extend) / 128)
				break;
		}
		if (j < extend_len - 1)
			continue;
		x = 3 * pr[1][i].other.x - 2 * pr[2][i].other.x;
		y = 3 * pr[1][i].other.y - 2 * pr[2][i].other.y;
		pr[0][i].all =
			PointRange(x, y, pr[1][i].other.x, pr[1][i].other.y);
	}
}

static void PressureSave(void)
{
	int i;

	if ((point_num & 0x1000) == 0) {
		for (i = 0; i < POINT_MAX; i++) {
			pressure_now[i] = 0;
			pressure_report[i] = 0;
		}
		return;
	}
	for (i = 0; i < POINT_MAX; i++) {
		pressure_now[i] = point_now[i].all >> 28;
		point_now[i].all &= ~(0xf << 28);
	}
}

static void PointPressure(void)
{
	int i, j;

	for (i = 0; i < POINT_MAX; i++) {
		if (pa[0][i] != 0 && pa[1][i] == 0) {
			pressure_report[i] = pa[0][i] * 5;
			for (j = 1; j < PRESSURE_DEEP; j++)
				pa[j][i] = pa[0][i];
			continue;
		}
		j = (pressure_report[i] + 1) / 2 + pa[0][i] + pa[1][i] +
		    (pa[2][i] + 1) / 2 - pressure_report[i];
		if (j >= 2)
			j -= 2;
		else if (j <= -2)
			j += 2;
		else
			j = 0;
		pressure_report[i] = pressure_report[i] + j;
	}
}

static void PressMask(void)
{
	int i, j;
	unsigned int press_max = press_mask & 0xff;
	unsigned int press_range_s = (press_mask >> 8) & 0xff;
	unsigned int press_range_d = (press_mask >> 16) & 0xff;
	unsigned int press_range;

	if (press_max == 0)
		return;
	for (i = 0; i < POINT_MAX; i++) {
		if (point_delay[i].other.able == 0) {
			point_delay[i].other.pres = 0;
			continue;
		}
		if (point_delay[i].other.delay >= 1 &&
		    point_delay[i].other.pres == 0) {
			if (pa[0][i] > pa[1][i])
				point_delay[i].other.able = 0;
			else
				point_delay[i].other.pres = 1;
		}
	}
	for (i = 0; i < POINT_MAX; i++) {
		if (pr[0][i].all == 0)
			continue;
		if (point_delay[i].other.mask == 0 &&
		    pressure_report[i] < press_max + 7)
			continue;
		point_delay[i].other.able = 0;
		point_delay[i].other.mask = 1;
		press_range = press_range_s * 64;
		if (pressure_report[i] > 7 + press_max)
			press_range += (pressure_report[i] - 7 - press_max) *
				       press_range_d;
		if (press_range == 0)
			continue;
		for (j = 0; j < POINT_MAX; j++) {
			if (i == j)
				continue;
			if (pr[0][j].all == 0 || point_delay[j].other.able == 0)
				continue;

			if (PointDistance(&pp[0][i], &pp[0][j]) <
			    press_range * press_range)
				point_delay[j].other.able = 0;
		}
	}
}

static void PressMove(void)
{
	int i;
	/* POINT_TYPE_ID point_press_move; */
	/* unsigned int press_move=0x01000010; */
	if (press_move == 0)
		return;
	if (pr[0][0].all == 0)
		goto press_move_err;
	for (i = 1; i < POINT_MAX; i++) {
		if (pr[0][i].all)
			goto press_move_err;
	}
	if (pressure_report[0] < (press_move & 0xff) + 7)
		goto press_move_err;
	if (point_press_move.all == 0) {
		point_press_move.all = pr[0][0].all;
	} else if (point_press_move.other.x && point_press_move.other.y) {
		if (PointDistance(&point_press_move, &pr[0][0]) >
		    (press_move >> 16) * (press_move >> 16)) {
			/* #define	x0		point_press_move.x */
			/* #define	y0		point_press_move.y */
			/* #define	x1		pr[0][0].x */
			/* #define	y1		pr[0][0].y */
			/* if(x1<x0 && y1<y0+(x0-x1) && y1+(x0-x1)>y0) */
			/* press_move = 1; */
			/* if(x1>x0 && y1<y0+(x1-x0) && y1+(x1-x0)>y0) */
			/* press_move = 2; */
			/* if(y1<y0 && x1<x0+(y0-y1) && x1+(y0-y1)>x0) */
			/* press_move = 3; */
			/* if(y1>y0 && x1<x0+(y1-y0) && x1+(y1-y0)>x0) */
			/* press_move = 4; */
			if (pr[0][0].other.x < point_press_move.other.x &&
			    pr[0][0].other.y <
				    point_press_move.other.y +
					    (point_press_move.other.x -
					     pr[0][0].other.x) &&
			    pr[0][0].other.y + (point_press_move.other.x -
						pr[0][0].other.x) >
				    point_press_move.other.y)
				point_press_move.all = 1;
			else if (pr[0][0].other.x > point_press_move.other.x &&
				 pr[0][0].other.y <
					 point_press_move.other.y +
						 (pr[0][0].other.x -
						  point_press_move.other.x) &&
				 pr[0][0].other.y + (pr[0][0].other.x -
						     point_press_move.other.x) >
					 point_press_move.other.y)
				point_press_move.all = 2;
			else if (pr[0][0].other.y < point_press_move.other.y &&
				 pr[0][0].other.x <
					 point_press_move.other.x +
						 (point_press_move.other.y -
						  pr[0][0].other.y) &&
				 pr[0][0].other.x + (point_press_move.other.y -
						     pr[0][0].other.y) >
					 point_press_move.other.x)
				point_press_move.all = 3;
			else if (pr[0][0].other.y > point_press_move.other.y &&
				 pr[0][0].other.x <
					 point_press_move.other.x +
						 (pr[0][0].other.y -
						  point_press_move.other.y) &&
				 pr[0][0].other.x + (pr[0][0].other.y -
						     point_press_move.other.y) >
					 point_press_move.other.x)
				point_press_move.all = 4;
		}
	} else {
	}
	return;
press_move_err:
	point_press_move.all = 0;
}

int gsl_PressMove(void)
{
	if (point_press_move.all <= 4)
		return point_press_move.all;
	else
		return 0;
}
/* EXPORT_SYMBOL(gsl_PressMove); */

void gsl_ReportPressure(unsigned int *p)
{
	int i;

	for (i = 0; i < POINT_MAX; i++) {
		if (i < point_num) {
			if (pressure_now[i] == 0)
				p[i] = 0;
			else if (pressure_now[i] <= 7)
				p[i] = 1;
			else if (pressure_now[i] > 63 + 7)
				p[i] = 63;
			else
				p[i] = pressure_now[i] - 7;
		} else
			p[i] = 0;
	}
}
/* EXPORT_SYMBOL(gsl_ReportPressure); */

int gsl_TouchNear(void)
{
	return 0;
}
/* EXPORT_SYMBOL(gsl_TouchNear); */

static void gsl_id_reg_init(int flag)
{
	int i, j;

	for (j = 0; j < POINT_DEEP; j++)
		for (i = 0; i < POINT_MAX; i++)
			point_array[j][i].all = 0;
	for (j = 0; j < PRESSURE_DEEP; j++)
		for (i = 0; i < POINT_MAX; i++)
			pressure_array[j][i] = 0;
	for (i = 0; i < POINT_MAX; i++) {
		point_delay[i].all = 0;
		filter_deep[i] = 0;
		point_decimal[i].all = 0;
	}
	for (i = 0; i < AVG_DEEP; i++)
		avg[i] = 0;
	point_edge.rate = 0;
	point_n = 0;
	if (flag)
		point_num = 0;
	prev_num = 0;
	point_shake = 0;
	reset_mask_send = 0;
	reset_mask_max = 0;
	reset_mask_count = 0;
	point_near = 0;
	point_corner = 0;
	global_state.all = 0;
	inte_count = 0;
	csensor_count = 0;
	point_press_move.all = 0;
	global_state.other.cc_128 = 0;
	prec_id.all = 0;
	for (i = 0; i < 64; i++) {
		if (coordinate_correct_coe_x[i] > 64 ||
		    coordinate_correct_coe_y[i] > 64) {
			global_state.other.cc_128 = 1;
			break;
		}
	}
}

static int DataCheck(void)
{
	if (drv_num == 0 || drv_num_nokey == 0 || sen_num == 0 ||
	    sen_num_nokey == 0)
		return 0;
	if (screen_x_max == 0 || screen_y_max == 0)
		return 0;
	return 1;
}

void gsl_DataInit(unsigned int *conf_in)
{
	ESP_LOGI(TAG,"gsl_DataInit");
	int i, j;
	unsigned int *conf;
	int len;

	gsl_id_reg_init(1);
	for (i = 0; i < POINT_MAX; i++)
		point_now[i].all = 0;
	conf = config_static;
	coordinate_correct_able = 0;
	for (i = 0; i < 32; i++) {
		coordinate_correct_coe_x[i] = i;
		coordinate_correct_coe_y[i] = i;
	}
	id_first_coe = 8;
	id_speed_coe = 128 * 128;
	id_static_coe = 64 * 64;
	average = 3 + 1;
	soft_average = 3;
	report_delay = 0;
	delay_key = 0;
	report_ahead = 0x9249249;
	report_delete = 0;

	for (i = 0; i < 4; i++)
		median_dis[i] = 0;
	shake_min = 0 * 0;
	for (i = 0; i < 2; i++) {
		match_y[i] = 0;
		match_x[i] = 0;
		ignore_y[i] = 0;
		ignore_x[i] = 0;
	}
	match_y[0] = 4096;
	match_x[0] = 4096;
	screen_y_max = 480;
	screen_x_max = 800;
	point_num_max = 10;
	drv_num = 16;
	sen_num = 10;
	drv_num_nokey = 16;
	sen_num_nokey = 10;
	for (i = 0; i < 4; i++)
		edge_cut[i] = 0;
	for (i = 0; i < 32; i++)
		stretch_array[i] = 0;
	for (i = 0; i < 16; i++)
		shake_all_array[i] = 0;
	reset_mask_dis = 0;
	reset_mask_type = 0;
	edge_start = 0;
	diagonal = 0;
	point_extend = 0;
	key_map_able = 0;
	for (i = 0; i < 8 * 3; i++)
		key_range_array[i] = 0;
	filter_able = 0;
	filter_coe[0] = (0 << 6 * 4) + (0 << 6 * 3) + (0 << 6 * 2) +
			(40 << 6 * 1) + (24 << 6 * 0);
	filter_coe[1] = (0 << 6 * 4) + (0 << 6 * 3) + (16 << 6 * 2) +
			(24 << 6 * 1) + (24 << 6 * 0);
	filter_coe[2] = (0 << 6 * 4) + (16 << 6 * 3) + (24 << 6 * 2) +
			(16 << 6 * 1) + (8 << 6 * 0);
	filter_coe[3] = (6 << 6 * 4) + (16 << 6 * 3) + (24 << 6 * 2) +
			(12 << 6 * 1) + (6 << 6 * 0);
	for (i = 0; i < 4; i++) {
		multi_x_array[i] = 0;
		multi_y_array[i] = 0;
	}
	point_repeat[0] = 32;
	point_repeat[1] = 96;
	edge_first = 0;
	edge_first_coe = 0x80;
	id_flag.all = 0;
	press_mask = 0;
	press_move = 0;
	stretch_mult = 0;
	/* ---------------------------------------------- */
	if (conf_in == NULL)
		return;

	if (conf_in[0] <= 0xfff) {
		if (ConfigCoorMulti(conf_in))
			len = 512;
		else if (ConfigFilter(conf_in))
			len = 256;
		else if (ConfigKeyMap(conf_in))
			len = 241;
		else
			len = 215;
	} else if (conf_in[1] <= CONFIG_LENGTH)
		len = conf_in[1];
	else
		len = CONFIG_LENGTH;
	for (i = 0; i < len; i++)
		conf[i] = conf_in[i];
	for (; i < CONFIG_LENGTH; i++)
		conf[i] = 0;
	if (conf_in[0] <= 0xfff) {
		coordinate_correct_able = conf[0];
		drv_num = conf[1];
		sen_num = conf[2];
		drv_num_nokey = conf[3];
		sen_num_nokey = conf[4];
		id_first_coe = conf[5];
		id_speed_coe = conf[6];
		id_static_coe = conf[7];
		average = conf[8];
		soft_average = conf[9];

		report_delay = conf[13];
		shake_min = conf[14];
		screen_y_max = conf[15];
		screen_x_max = conf[16];
		point_num_max = conf[17];
		global_flag.all = conf[18];
		for (i = 0; i < 4; i++)
			median_dis[i] = (unsigned char)conf[19 + i];
		for (i = 0; i < 2; i++) {
			match_y[i] = conf[23 + i];
			match_x[i] = conf[25 + i];
			ignore_y[i] = conf[27 + i];
			ignore_x[i] = conf[29 + i];
		}
		for (i = 0; i < 64; i++) {
			coordinate_correct_coe_x[i] = conf[31 + i];
			coordinate_correct_coe_y[i] = conf[95 + i];
		}
		for (i = 0; i < 4; i++)
			edge_cut[i] = conf[159 + i];
		for (i = 0; i < 32; i++)
			stretch_array[i] = conf[163 + i];
		for (i = 0; i < 16; i++)
			shake_all_array[i] = conf[195 + i];
		reset_mask_dis = conf[213];
		reset_mask_type = conf[214];
		edge_start = conf[216];
		key_map_able = conf[217];
		for (i = 0; i < 8 * 3; i++)
			key_range_array[i] = conf[218 + i];
		filter_able = conf[242];
		for (i = 0; i < 4; i++)
			filter_coe[i] = conf[243 + i];
		for (i = 0; i < 4; i++)
			multi_x_array[i] = conf[247 + i];
		for (i = 0; i < 4; i++)
			multi_y_array[i] = conf[251 + i];
		diagonal = conf[255];
		for (j = 0; j < 4; j++)
			for (i = 0; i < 64; i++)
				multi_group[j][i] = conf[256 + i + j * 64];
		for (j = 0; j < 4; j++) {
			for (i = 0; i < 8; i++) {
				ps_coe[j][i] = conf[256 + 64 * 3 + i + j * 8];
				pr_coe[j][i] =
					conf[256 + 64 * 3 + i + j * 8 + 32];
			}
		}
		/* ----------------------- */
		/* near_set[0] = 0; */
		/* near_set[1] = 0; */
	} else {
		global_flag.all = conf[0x10];
		point_num_max = conf[0x11];
		drv_num = conf[0x12] & 0xffff;
		sen_num = conf[0x12] >> 16;
		drv_num_nokey = conf[0x13] & 0xffff;
		sen_num_nokey = conf[0x13] >> 16;
		screen_x_max = conf[0x14] & 0xffff;
		screen_y_max = conf[0x14] >> 16;
		average = conf[0x15];
		reset_mask_dis = conf[0x16];
		reset_mask_type = conf[0x17];
		point_repeat[0] = conf[0x18] >> 16;
		point_repeat[1] = conf[0x18] & 0xffff;
		/* conf[0x19~0x1f] */
		/* near_set[0] = conf[0x19]>>16; */
		/* near_set[1] = conf[0x19]&0xffff; */
		diagonal = conf[0x1a];
		point_extend = conf[0x1b];
		edge_start = conf[0x1c];
		press_move = conf[0x1d];
		press_mask = conf[0x1e];
		id_flag.all = conf[0x1f];
		/* ------------------------- */

		id_first_coe = conf[0x20];
		id_speed_coe = conf[0x21];
		id_static_coe = conf[0x22];
		match_y[0] = conf[0x23] >> 16;
		match_y[1] = conf[0x23] & 0xffff;
		match_x[0] = conf[0x24] >> 16;
		match_x[1] = conf[0x24] & 0xffff;
		ignore_y[0] = conf[0x25] >> 16;
		ignore_y[1] = conf[0x25] & 0xffff;
		ignore_x[0] = conf[0x26] >> 16;
		ignore_x[1] = conf[0x26] & 0xffff;
		edge_cut[0] = (conf[0x27] >> 24) & 0xff;
		edge_cut[1] = (conf[0x27] >> 16) & 0xff;
		edge_cut[2] = (conf[0x27] >> 8) & 0xff;
		edge_cut[3] = (conf[0x27] >> 0) & 0xff;
		report_delay = conf[0x28];
		shake_min = conf[0x29];
		for (i = 0; i < 16; i++) {
			stretch_array[i * 2 + 0] = conf[0x2a + i] & 0xffff;
			stretch_array[i * 2 + 1] = conf[0x2a + i] >> 16;
		}
		for (i = 0; i < 8; i++) {
			shake_all_array[i * 2 + 0] = conf[0x3a + i] & 0xffff;
			shake_all_array[i * 2 + 1] = conf[0x3a + i] >> 16;
		}
		report_ahead = conf[0x42];
		/* key_dead_time			= conf[0x43]; */
		/* point_dead_time			= conf[0x44]; */
		/* point_dead_time2		= conf[0x45]; */
		/* point_dead_distance		= conf[0x46]; */
		/* point_dead_distance2	= conf[0x47]; */
		edge_first = conf[0x48];
		edge_first_coe = conf[0x49];
		delay_key = conf[0x4a];
		report_delete = conf[0x4b];
		stretch_mult = conf[0x4c];

		for (i = 0; i < 16; i++) {
			stretch_active[i * 2 + 0] = conf[0x50 + i] & 0xffff;
			stretch_active[i * 2 + 1] = conf[0x50 + i] >> 16;
		}
		/* goto_test */

		key_map_able = conf[0x60];
		for (i = 0; i < 8 * 3; i++)
			key_range_array[i] = conf[0x61 + i];

		coordinate_correct_able = conf[0x100];
		for (i = 0; i < 4; i++) {
			multi_x_array[i] = conf[0x101 + i];
			multi_y_array[i] = conf[0x105 + i];
		}
		for (i = 0; i < 64; i++) {
			coordinate_correct_coe_x[i] =
				(conf[0x109 + i / 4] >> (i % 4 * 8)) & 0xff;
			coordinate_correct_coe_y[i] =
				(conf[0x109 + 64 / 4 + i / 4] >> (i % 4 * 8)) &
				0xff;
		}
		for (j = 0; j < 4; j++)
			for (i = 0; i < 64; i++)
				multi_group[j][i] = (conf[0x109 + 64 / 4 * 2 +
							  (i + j * 64) / 4] >>
						     ((i + j * 64) % 4 * 8)) &
						    0xff;

		filter_able = conf[0x180];
		for (i = 0; i < 4; i++)
			filter_coe[i] = conf[0x181 + i];
		for (i = 0; i < 4; i++)
			median_dis[i] = (unsigned char)conf[0x185 + i];
		for (j = 0; j < 4; j++) {
			for (i = 0; i < 8; i++) {
				ps_coe[j][i] = conf[0x189 + i + j * 8];
				pr_coe[j][i] = conf[0x189 + i + j * 8 + 32];
			}
		}
	}
	/* --------------------------------------------- */
	gsl_id_reg_init(0);
	/* --------------------------------------------- */
	if (average == 0)
		average = 4;
	for (i = 0; i < 8; i++) {
		if (shake_all_array[i * 2] & 0x8000)
			shake_all_array[i * 2] =
				shake_all_array[i * 2] & ~0x8000;
		else
			shake_all_array[i * 2] = Sqrt(shake_all_array[i * 2]);
	}
	for (i = 0; i < 2; i++) {
		if (match_x[i] & 0x8000)
			match_x[i] |= 0xffff0000;
		if (match_y[i] & 0x8000)
			match_y[i] |= 0xffff0000;
		if (ignore_x[i] & 0x8000)
			ignore_x[i] |= 0xffff0000;
		if (ignore_y[i] & 0x8000)
			ignore_y[i] |= 0xffff0000;
	}
	for (i = 0; i < CONFIG_LENGTH; i++)
		config_static[i] = 0;
}


unsigned int gsl_version_id(void)
{
	return GSL_VERSION;
}


unsigned int gsl_mask_tiaoping(void)
{
	// printf("reset_mask_send:%d\r\n",reset_mask_send);
	return reset_mask_send;
}

static void GetFlag(void)
{
	int i = 0;
	int num_save;

	for (i = AVG_DEEP - 1; i; i--)
		avg[i] = avg[i - 1];
	avg[0] = 0;
	if ((point_num & 0x8000) != 0) {

		if ((point_num & 0xff000000) == 0x59000000)
			avg[0] = (point_num >> 16) & 0xff;
	}
	if (((point_num & 0x100) != 0) ||
	    ((point_num & 0x200) != 0 && global_state.other.reset == 1)) {
		gsl_id_reg_init(0);
	}
	if ((point_num & 0x300) == 0)
		global_state.other.reset = 1;

	if (point_num & 0x400)
		global_state.other.only = 1;
	else
		global_state.other.only = 0;
	if (point_num & 0x2000)
		global_state.other.interpolation = INTE_INIT;
	else if (global_state.other.interpolation)
		global_state.other.interpolation--;
	if (point_num & 0x4000)
		global_state.other.ex = 1;
	else
		global_state.other.ex = 0;
	if ((point_num & 0xff) != 0) {
		global_state.other.active_prev = global_state.other.active;
		if ((point_num & 0x800) != 0)
			global_state.other.active = 1;
		else
			global_state.other.active = 0;
		if (global_state.other.active !=
		    global_state.other.active_prev) {
			if (global_state.other.active) {
				if (prec_id.other.num)
					gsl_id_reg_init(1);
				else
					gsl_id_reg_init(0);
				global_state.other.active = 1;
				global_state.other.active_prev = 1;
			} else
				gsl_id_reg_init(0);
		}
	}
	inte_count++;
	csensor_count = ((unsigned int)point_num) >> 16;
	num_save = point_num & 0xff;
	if (num_save > POINT_MAX)
		num_save = POINT_MAX;
	for (i = 0; i < POINT_MAX; i++) {
		if (i >= num_save)
			point_now[i].all = 0;
	}
	point_num = (point_num & (~0xff)) + num_save;
}

static void PointIgnore(void)
{
	int i, x, y;

	if (id_flag.other.ignore_pri == 0)
		return;
	for (i = 0; i < point_num; i++) {
		if (point_now[i].other.key)
			continue;
		y = point_now[i].other.y * (int)screen_y_max /
		    ((int)sen_num_nokey * 64);
		x = point_now[i].other.x * (int)screen_x_max /
		    ((int)drv_num_nokey * 64);
		if ((ignore_y[0] != 0 || ignore_y[1] != 0)) {
			if (y < ignore_y[0])
				point_now[i].all = 0;
			if (ignore_y[1] <= screen_y_max / 2 &&
			    y > screen_y_max - ignore_y[1])
				point_now[i].all = 0;
			if (ignore_y[1] >= screen_y_max / 2 && y > ignore_y[1])
				point_now[i].all = 0;
		}
		if (ignore_x[0] != 0 || ignore_x[1] != 0) {
			if (x < ignore_x[0])
				point_now[i].all = 0;
			if (ignore_x[1] <= screen_x_max / 2 &&
			    x > screen_x_max - ignore_x[1])
				point_now[i].all = 0;
			if (ignore_x[1] >= screen_x_max / 2 && x > ignore_x[1])
				point_now[i].all = 0;
		}
	}
	x = 0;
	for (i = 0; i < point_num; i++) {
		if (point_now[i].all == 0)
			continue;
		point_now[x++] = point_now[i];
	}
	point_num = x;
}

void gsl_alg_id_main(struct gsl_touch_info *cinfo)
{
	int i;
	// ESP_LOGI(TAG,"gsl_alg_id_main");
	point_num = cinfo->finger_num;
	for (i = 0; i < POINT_MAX; i++)
		point_now[i].all = (cinfo->id[i] << 28) | (cinfo->x[i] << 16) |
				   cinfo->y[i];

	GetFlag();
	if (DataCheck() == 0) {
		point_num = 0;
		cinfo->finger_num = 0;
		return;
	}
	PressureSave();
	point_num &= 0xff;
	PointIgnore();
	PointCoor();
	CoordinateCorrect();
	PointEdge();
	PointRound();
	PointRepeat();
	GetPointNum(point_now);
	PointPointer();
	PointPredict();
	PointId();
	PointNewId();
	PointOrder();
	PointCross();
	GetPointNum(pp[0]);

	prev_num = point_num;
	ResetMask();
	PointStretch();
	PointDiagonal();
	PointFilter();
	GetPointNum(pr[0]);

	PointDelay();
	PointMenu();
	PointExtend();
	PointPressure();
	PressMove();
	PressMask();
	PointReport(cinfo);
}

//=====================================================

//esp_lcd_touch.h

/*
 * SPDX-FileCopyrightText: 2022 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @file
 * @brief ESP LCD touch
 */

#pragma once

#include <stdbool.h>
#include "sdkconfig.h"
#include "esp_err.h"
#include "driver/gpio.h"
#include "esp_lcd_panel_io.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS     (1)
#define CONFIG_ESP_LCD_TOUCH_MAX_POINTS     (5)

/**
 * @brief Touch controller type
 *
 */
typedef struct esp_lcd_touch_s esp_lcd_touch_t;
typedef esp_lcd_touch_t *esp_lcd_touch_handle_t;

/**
 * @brief Touch controller interrupt callback type
 *
 */
typedef void (*esp_lcd_touch_interrupt_callback_t)(esp_lcd_touch_handle_t tp);

/**
 * @brief Touch Configuration Type
 *
 */
typedef struct {
    uint16_t x_max; /*!< X coordinates max (for mirroring) */
    uint16_t y_max; /*!< Y coordinates max (for mirroring) */

    gpio_num_t rst_gpio_num;    /*!< GPIO number of reset pin */
    gpio_num_t int_gpio_num;    /*!< GPIO number of interrupt pin */

    struct {
        unsigned int reset: 1;    /*!< Level of reset pin in reset */
        unsigned int interrupt: 1;/*!< Active Level of interrupt pin */
    } levels;

    struct {
        unsigned int swap_xy: 1;  /*!< Swap X and Y after read coordinates */
        unsigned int mirror_x: 1; /*!< Mirror X after read coordinates */
        unsigned int mirror_y: 1; /*!< Mirror Y after read coordinates */
    } flags;

    /*!< User callback called after get coordinates from touch controller for apply user adjusting */
    void (*process_coordinates)(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);
    /*!< User callback called after the touch interrupt occured */
    esp_lcd_touch_interrupt_callback_t interrupt_callback;
} esp_lcd_touch_config_t;

typedef struct {
    uint8_t points; /*!< Count of touch points saved */

    struct {
        uint16_t x; /*!< X coordinate */
        uint16_t y; /*!< Y coordinate */
        uint16_t strength; /*!< Strength */
    } coords[CONFIG_ESP_LCD_TOUCH_MAX_POINTS];

#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
    uint8_t buttons; /*!< Count of buttons states saved */

    struct {
        uint8_t status; /*!< Status of button */
    } button[CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS];
#endif

    portMUX_TYPE lock; /*!< Lock for read/write */
} esp_lcd_touch_data_t;

/**
 * @brief Declare of Touch Type
 *
 */
struct esp_lcd_touch_s {

    /**
     * @brief Read data from touch controller (mandatory)
     *
     * @note This function is usually blocking.
     *
     * @param tp: Touch handler
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*read_data)(esp_lcd_touch_handle_t tp);

    /**
     * @brief Get coordinates from touch controller (mandatory)
     *
     * @param tp: Touch handler
     * @param x: Array of X coordinates
     * @param y: Array of Y coordinates
     * @param strength: Array of strengths
     * @param point_num: Count of points touched (equals with count of items in x and y array)
     * @param max_point_num: Maximum count of touched points to return (equals with max size of x and y array)
     *
     * @return
     *      - Returns true, when touched and coordinates readed. Otherwise returns false.
     */
    bool (*get_xy)(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);


#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
    /**
     * @brief Get button state (optional)
     *
     * @param tp: Touch handler
     * @param n: Button index
     * @param state: Button state
     *
     * @return
     *      - Returns true, when touched and coordinates readed. Otherwise returns false.
     */
    esp_err_t (*get_button_state)(esp_lcd_touch_handle_t tp, uint8_t n, uint8_t *state);
#endif

    /**
     * @brief Swap X and Y after read coordinates (optional)
     *        If set, then not used SW swapping.
     *
     * @param tp: Touch handler
     * @param swap: Set swap value
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*set_swap_xy)(esp_lcd_touch_handle_t tp, bool swap);

    /**
     * @brief Are X and Y coordinates swapped (optional)
     *
     * @param tp: Touch handler
     * @param swap: Get swap value
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*get_swap_xy)(esp_lcd_touch_handle_t tp, bool *swap);

    /**
     * @brief Mirror X after read coordinates
     *        If set, then not used SW mirroring.
     *
     * @param tp: Touch handler
     * @param mirror: Set X mirror value
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*set_mirror_x)(esp_lcd_touch_handle_t tp, bool mirror);

    /**
     * @brief Is mirrored X (optional)
     *
     * @param tp: Touch handler
     * @param mirror: Get X mirror value
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*get_mirror_x)(esp_lcd_touch_handle_t tp, bool *mirror);

    /**
     * @brief Mirror Y after read coordinates
     *        If set, then not used SW mirroring.
     *
     * @param tp: Touch handler
     * @param mirror: Set Y mirror value
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*set_mirror_y)(esp_lcd_touch_handle_t tp, bool mirror);

    /**
     * @brief Is mirrored Y (optional)
     *
     * @param tp: Touch handler
     * @param mirror: Get Y mirror value
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*get_mirror_y)(esp_lcd_touch_handle_t tp, bool *mirror);

    /**
     * @brief Delete Touch
     *
     * @param tp: Touch handler
     *
     * @return
     *      - ESP_OK on success, otherwise returns ESP_ERR_xxx
     */
    esp_err_t (*del)(esp_lcd_touch_handle_t tp);

    /**
     * @brief Configuration structure
     */
    esp_lcd_touch_config_t config;

    /**
     * @brief Communication interface
     */
    esp_lcd_panel_io_handle_t io;

    /**
     * @brief Data structure
     */
    esp_lcd_touch_data_t data;
};

/**
 * @brief Read data from touch controller
 *
 * @note This function is usually blocking.
 *
 * @param tp: Touch handler
 *
 * @return
 *     - ESP_OK                 on success
 *     - ESP_ERR_INVALID_ARG    parameter error
 *     - ESP_FAIL               sending command error, slave hasn't ACK the transfer
 *     - ESP_ERR_INVALID_STATE  I2C driver not installed or not in master mode
 *     - ESP_ERR_TIMEOUT        operation timeout because the bus is busy
 */
esp_err_t esp_lcd_touch_read_data(esp_lcd_touch_handle_t tp);

/**
 * @brief Read coordinates from touch controller
 *
 * @param tp: Touch handler
 * @param x: Array of X coordinates
 * @param y: Array of Y coordinates
 * @param strength: Array of the strengths (can be NULL)
 * @param point_num: Count of points touched (equals with count of items in x and y array)
 * @param max_point_num: Maximum count of touched points to return (equals with max size of x and y array)
 *
 * @return
 *      - Returns true, when touched and coordinates readed. Otherwise returns false.
 */
bool esp_lcd_touch_get_coordinates(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);


#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
/**
 * @brief Get button state
 *
 * @param tp: Touch handler
 * @param n: Button index
 * @param state: Button state
 *
 * @return
 *      - ESP_OK                    on success
 *      - ESP_ERR_NOT_SUPPORTED     if this function is not supported by controller
 *      - ESP_ERR_INVALID_ARG       if bad button index
 */
esp_err_t esp_lcd_touch_get_button_state(esp_lcd_touch_handle_t tp, uint8_t n, uint8_t *state);
#endif

/**
 * @brief Swap X and Y after read coordinates
 *
 * @param tp: Touch handler
 * @param swap: Set swap value
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_set_swap_xy(esp_lcd_touch_handle_t tp, bool swap);

/**
 * @brief Are X and Y coordinates swapped
 *
 * @param tp: Touch handler
 * @param swap: Get swap value
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_get_swap_xy(esp_lcd_touch_handle_t tp, bool *swap);

/**
 * @brief Mirror X after read coordinates
 *
 * @param tp: Touch handler
 * @param mirror: Set X mirror value
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_set_mirror_x(esp_lcd_touch_handle_t tp, bool mirror);

/**
 * @brief Is mirrored X
 *
 * @param tp: Touch handler
 * @param mirror: Get X mirror value
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_get_mirror_x(esp_lcd_touch_handle_t tp, bool *mirror);

/**
 * @brief Mirror Y after read coordinates
 *
 * @param tp: Touch handler
 * @param mirror: Set Y mirror value
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_set_mirror_y(esp_lcd_touch_handle_t tp, bool mirror);

/**
 * @brief Is mirrored Y
 *
 * @param tp: Touch handler
 * @param mirror: Get Y mirror value
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_get_mirror_y(esp_lcd_touch_handle_t tp, bool *mirror);

/**
 * @brief Delete touch (free all allocated memory and restart HW)
 *
 * @param tp: Touch handler
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_del(esp_lcd_touch_handle_t tp);

/**
 * @brief Register user callback called after the touch interrupt occured
 *
 * @param tp: Touch handler
 * @param callback: Interrupt callback
 *
 * @return
 *      - ESP_OK on success
 */
esp_err_t esp_lcd_touch_register_interrupt_callback(esp_lcd_touch_handle_t tp, esp_lcd_touch_interrupt_callback_t callback);

#ifdef __cplusplus
}
#endif

//==========================================================

//esp_lcd_touch.c

/*
 * SPDX-FileCopyrightText: 2015-2022 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_system.h"
#include "esp_err.h"
#include "esp_check.h"
#include "esp_log.h"
#include "esp_lcd_touch.h"

static const char *TAG = "TP";

/*******************************************************************************
* Function definitions
*******************************************************************************/

/*******************************************************************************
* Local variables
*******************************************************************************/

/*******************************************************************************
* Public API functions
*******************************************************************************/

esp_err_t esp_lcd_touch_read_data(esp_lcd_touch_handle_t tp)
{
    assert(tp != NULL);
    assert(tp->read_data != NULL);

    return tp->read_data(tp);
}

bool esp_lcd_touch_get_coordinates(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num)
{
    bool touched = false;

    assert(tp != NULL);
    assert(x != NULL);
    assert(y != NULL);
    assert(tp->get_xy != NULL);

    touched = tp->get_xy(tp, x, y, strength, point_num, max_point_num);
    if (!touched) {
        return false;
    }

    /* Process coordinates by user */
    if (tp->config.process_coordinates != NULL) {
        tp->config.process_coordinates(tp, x, y, strength, point_num, max_point_num);
    }

    /* Software coordinates adjustment needed */
    bool sw_adj_needed = ((tp->config.flags.mirror_x && (tp->set_mirror_x == NULL)) ||
                          (tp->config.flags.mirror_y && (tp->set_mirror_y == NULL)) ||
                          (tp->config.flags.swap_xy && (tp->set_swap_xy == NULL)));

    /* Adjust all coordinates */
    for (int i = 0; (sw_adj_needed && i < *point_num); i++) {

        /*  Mirror X coordinates (if not supported by HW) */
        if (tp->config.flags.mirror_x && tp->set_mirror_x == NULL) {
            x[i] = tp->config.x_max - x[i];
        }

        /*  Mirror Y coordinates (if not supported by HW) */
        if (tp->config.flags.mirror_y && tp->set_mirror_y == NULL) {
            y[i] = tp->config.y_max - y[i];
        }

        /* Swap X and Y coordinates (if not supported by HW) */
        if (tp->config.flags.swap_xy && tp->set_swap_xy == NULL) {
            uint16_t tmp = x[i];
            x[i] = y[i];
            y[i] = tmp;
        }
    }

    return touched;
}

#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
esp_err_t esp_lcd_touch_get_button_state(esp_lcd_touch_handle_t tp, uint8_t n, uint8_t *state)
{
    assert(tp != NULL);
    assert(state != NULL);

    *state = 0;

    if (tp->get_button_state) {
        return tp->get_button_state(tp, n, state);
    } else {
        return ESP_ERR_NOT_SUPPORTED;
    }

    return ESP_OK;
}
#endif

esp_err_t esp_lcd_touch_set_swap_xy(esp_lcd_touch_handle_t tp, bool swap)
{
    assert(tp != NULL);

    tp->config.flags.swap_xy = swap;

    /* Is swap supported by HW? */
    if (tp->set_swap_xy) {
        return tp->set_swap_xy(tp, swap);
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_get_swap_xy(esp_lcd_touch_handle_t tp, bool *swap)
{
    assert(tp != NULL);
    assert(swap != NULL);

    /* Is swap supported by HW? */
    if (tp->get_swap_xy) {
        return tp->get_swap_xy(tp, swap);
    } else {
        *swap = tp->config.flags.swap_xy;
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_set_mirror_x(esp_lcd_touch_handle_t tp, bool mirror)
{
    assert(tp != NULL);

    tp->config.flags.mirror_x = mirror;

    /* Is mirror supported by HW? */
    if (tp->set_mirror_x) {
        return tp->set_mirror_x(tp, mirror);
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_get_mirror_x(esp_lcd_touch_handle_t tp, bool *mirror)
{
    assert(tp != NULL);
    assert(mirror != NULL);

    /* Is swap supported by HW? */
    if (tp->get_mirror_x) {
        return tp->get_mirror_x(tp, mirror);
    } else {
        *mirror = tp->config.flags.mirror_x;
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_set_mirror_y(esp_lcd_touch_handle_t tp, bool mirror)
{
    assert(tp != NULL);

    tp->config.flags.mirror_y = mirror;

    /* Is mirror supported by HW? */
    if (tp->set_mirror_y) {
        return tp->set_mirror_y(tp, mirror);
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_get_mirror_y(esp_lcd_touch_handle_t tp, bool *mirror)
{
    assert(tp != NULL);
    assert(mirror != NULL);

    /* Is swap supported by HW? */
    if (tp->get_mirror_y) {
        return tp->get_mirror_y(tp, mirror);
    } else {
        *mirror = tp->config.flags.mirror_y;
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_del(esp_lcd_touch_handle_t tp)
{
    assert(tp != NULL);

    if (tp->del != NULL) {
        return tp->del(tp);
    }

    return ESP_OK;
}

esp_err_t esp_lcd_touch_register_interrupt_callback(esp_lcd_touch_handle_t tp, esp_lcd_touch_interrupt_callback_t callback)
{
    esp_err_t ret = ESP_OK;
    assert(tp != NULL);

    /* Interrupt pin is not selected */
    if (tp->config.int_gpio_num == GPIO_NUM_NC) {
        return ESP_ERR_INVALID_ARG;
    }

    tp->config.interrupt_callback = callback;

    if (callback != NULL) {
        ret = gpio_install_isr_service(0);
        /* ISR service can be installed from user before, then it returns invalid state */
        if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
            ESP_LOGE(TAG, "GPIO ISR install failed");
            return ret;
        }
        /* Add GPIO ISR handler */
        ret = gpio_intr_enable(tp->config.int_gpio_num);
        ESP_RETURN_ON_ERROR(ret, TAG, "GPIO ISR install failed");
        ret = gpio_isr_handler_add(tp->config.int_gpio_num, (gpio_isr_t)tp->config.interrupt_callback, tp);
        ESP_RETURN_ON_ERROR(ret, TAG, "GPIO ISR install failed");
    } else {
        /* Remove GPIO ISR handler */
        ret = gpio_isr_handler_remove(tp->config.int_gpio_num);
        ESP_RETURN_ON_ERROR(ret, TAG, "GPIO ISR remove handler failed");
        ret = gpio_intr_disable(tp->config.int_gpio_num);
        ESP_RETURN_ON_ERROR(ret, TAG, "GPIO ISR disable failed");
    }

    return ESP_OK;
}

//=====================================================================

//esp_lcd_gsl3680.h

#ifndef _LCD_GSL3680_H
#define _LCD_GSL3680_H

#include "esp_lcd_touch.h"


#define MAX_FINGER_NUM      3
#define TP_MULTI_SUCCESS    0

#define TP_PEN_NONE         0
#define TP_PEN_MOVE         1
#define TP_PEN_UP           2
#define TP_PEN_DOWN         3

#define TG_NO_DETECT        0
#define TG_ZOOM_IN          1
#define TG_ZOOM_OUT         2
#define TG_UNKNOWN_STATE    3

#define TP_UP_MSG           0
#define TP_DOWN_MSG         1
#define TP_MOVE_MSG         1
#define TP_MAX_MSG          0

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned int DAWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;

typedef int s32;
typedef short s16;
typedef char s8;

typedef DAWORD uint32;
typedef BYTE uint8;
typedef WORD uint16;
typedef s32 int32;
typedef s16 int16;
typedef BYTE TP_STATE_E;
typedef BYTE TG_STATE_E;
typedef DAWORD TP_IOCTL_CMD_E;

typedef struct _XY_DATA_T{
	WORD x_position,y_position;
	BYTE finger_id;
}XY_DATA_T;

typedef struct _TPDSVR_SIG_T{
	WORD x_key, y_key;
	BYTE cur_index;
	TG_STATE_E gesture_type;
	WORD num_of_point;
	BYTE SignalCode;
	XY_DATA_T xy_position[3];
}TPDSVR_SIG_T;

esp_err_t esp_lcd_touch_new_i2c_gsl3680(esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *out_touch);

#define ESP_LCD_TOUCH_IO_I2C_GSL3680_ADDRESS          (0x40)

typedef struct {
    uint8_t dev_addr;  /*!< I2C device address */
} esp_lcd_touch_io_gsl3680_config_t;

struct fw_data
{
	char offset;
	uint32_t val;
};

/**
 * @brief Touch IO configuration structure
 *
 */
#define ESP_LCD_TOUCH_IO_I2C_GSL3680_CONFIG()           \
    {                                       \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_GSL3680_ADDRESS, \
        .control_phase_bytes = 1,           \
        .dc_bit_offset = 0,                 \
        .lcd_cmd_bits = 8,                 \
        .flags =                            \
        {                                   \
            .disable_control_phase = 1,     \
        }                                   \
    }


#ifdef __cplusplus
}
#endif

static const struct fw_data GSLX680_FW[] = {

{0xf0,0x2},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x000000b0},
{0x64,0xf801000b},
{0x68,0x00066414},
{0x6c,0x1001020a},
{0x70,0x00000fff},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x0e1a0e1a},
{0xf0,0x3},
{0x00,0x930ac1d5},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00005100},
{0x28,0x00008e00},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x000000cd},
{0x54,0x0000008c},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x1a0ac00a},
{0x68,0x00000002},
{0x6c,0x0000000f},
{0x70,0x00000000},
{0x74,0xffffffff},
{0x78,0xffffffec},
{0x7c,0x00000000},
{0xf0,0x4},
{0x00,0x00000000},
{0x04,0x0001660b},
{0x08,0x00000064},
{0x0c,0x00000000},
{0x10,0xfe0cff06},
{0x14,0x07d00000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00010000},
{0x34,0x00000fff},
{0x38,0x0000000a},
{0x3c,0x00000258},
{0x40,0x00000000},
{0x44,0x04020a00},
{0x48,0x0014012c},
{0x4c,0xc0040003},
{0x50,0x00000000},
{0x54,0x00010203},
{0x58,0x04050607},
{0x5c,0x08090a0b},
{0x60,0x0c0d0e0f},
{0x64,0x10111213},
{0x68,0x14151617},
{0x6c,0x18191a1b},
{0x70,0x1c1d1e1f},
{0x74,0x0014000a},
{0x78,0x80808080},
{0x7c,0xcba981f4},
{0xf0,0x5},
{0x00,0x00000000},
{0x04,0x0000000a},
{0x08,0x000000b4},
{0x0c,0x404d4040},
{0x10,0x0000000a},
{0x14,0x00000000},
{0x18,0x00000fff},
{0x1c,0x10170002},
{0x20,0x10110000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000400},
{0x30,0x80808080},
{0x34,0x80808080},
{0x38,0x80808080},
{0x3c,0x80808080},
{0x40,0x80808080},
{0x44,0x80808080},
{0x48,0x80808080},
{0x4c,0x80808000},
{0x50,0xffffffff},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000220},
{0x78,0x0000001a},
{0x7c,0x0000000e},
{0xf0,0x6},
{0x00,0x0000001a},
{0x04,0x00000000},
{0x08,0x0000000e},
{0x0c,0x04030402},
{0x10,0x00000032},
{0x14,0x1414010a},
{0x18,0x00000001},
{0x1c,0x00000001},
{0x20,0x00002904},
{0x24,0x00000320},
{0x28,0x00000500},
{0x2c,0xf801000b},
{0x30,0xf8010005},
{0x34,0x00000003},
{0x38,0x00000003},
{0x3c,0x00000fff},
{0x40,0x80000000},
{0x44,0x00180018},
{0x48,0x00000fff},
{0x4c,0x04040402},
{0x50,0x00020001},
{0x54,0x00000e10},
{0x58,0x000a012c},
{0x5c,0x00806410},
{0x60,0x10200800},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x0000014a},
{0x78,0x000a003c},
{0x7c,0x00000000},
{0xf0,0x7},
{0x00,0x01060009},
{0x04,0x0308020b},
{0x08,0x050a040d},
{0x0c,0x070c0610},
{0x10,0x09130812},
{0x14,0x00123456},
{0x18,0x00000000},
{0x1c,0x000a0078},
{0x20,0x00001081},
{0x24,0xff080010},
{0x28,0xff080120},
{0x2c,0xff080140},
{0x30,0xff080160},
{0x34,0x002100f0},
{0x38,0x001c00d0},
{0x3c,0x001700b0},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x40000d00},
{0x4c,0x320f0f03},
{0x50,0x00000000},
{0x54,0x00000004},
{0x58,0x00000000},
{0x5c,0x000c0001},
{0x60,0x0018000d},
{0x64,0x00190019},
{0x68,0x00000000},
{0x6c,0x000b0000},
{0x70,0x000b0000},
{0x74,0x00000000},
{0x78,0x00012345},
{0x7c,0x006789ab},
{0xf0,0x8},
{0x00,0x020f222f},
{0x04,0x224f226f},
{0x08,0x228f22af},
{0x0c,0x22cf22ef},
{0x10,0x230f232f},
{0x14,0x234f236f},
{0x18,0x238f41f0},
{0x1c,0x41f141f2},
{0x20,0x41f341f4},
{0x24,0x41f541f6},
{0x28,0x41f741f8},
{0x2c,0x41f941fa},
{0x30,0x41fb71fc},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x01030507},
{0x44,0x090b0d00},
{0x48,0x00000000},
{0x4c,0x02040608},
{0x50,0x0a0c0e00},
{0x54,0x00000000},
{0x58,0x00060005},
{0x5c,0x00000008},
{0x60,0x000001c2},
{0x64,0x00000201},
{0x68,0x00000804},
{0x6c,0x006600cd},
{0x70,0x000000cd},
{0x74,0x0000008c},
{0x78,0x00000000},
{0x7c,0x0000000e},
{0xf0,0x9},
{0x00,0xff080094},
{0x04,0x00070011},
{0x08,0xff080090},
{0x0c,0x00040000},
{0x10,0xff080068},
{0x14,0x00030000},
{0x18,0xff080064},
{0x1c,0x01002582},
{0x20,0xff080060},
{0x24,0x00200000},
{0x28,0xff08004c},
{0x2c,0x00197fff},
{0x30,0xfffffff0},
{0x34,0x00000000},
{0x38,0xfffffff0},
{0x3c,0x00000000},
{0x40,0xfffffff0},
{0x44,0x00000000},
{0x48,0xfffffff0},
{0x4c,0x00000000},
{0x50,0xfffffff0},
{0x54,0x00000000},
{0x58,0xfffffff0},
{0x5c,0x00000000},
{0x60,0xfffffff0},
{0x64,0x00000000},
{0x68,0xfffffff0},
{0x6c,0x00000000},
{0x70,0xfffffff0},
{0x74,0x00000000},
{0x78,0xfffffff0},
{0x7c,0x00000000},
/*
{0xf0,0xe0},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x006401f4},
{0x44,0x00640064},
{0x48,0x01900064},
{0x4c,0x00500190},
{0x50,0x00500050},
{0x54,0x012c0050},
{0x58,0x012c012c},
{0x5c,0x003c012c},
{0x60,0x00640014},
{0x64,0x00640064},
{0x68,0x00000032},
{0x6c,0x00500000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0xe1},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000002},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0xe2},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0xe3},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0xe4},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0xe5},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0xe6},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
*/



{0xf0,0x1e},
{0x00,0x5a5a0f00},
{0x04,0x00002bdc},
{0x08,0x00002c50},
{0x0c,0x00002cd0},
{0x10,0x00002e10},
{0x14,0x00002f0c},
{0x18,0x000030c0},
{0x1c,0x00003254},
{0x20,0x00003270},
{0x24,0x00003418},
{0x28,0x00003550},
{0x2c,0x00003600},
{0x30,0x00003970},
{0x34,0x00003a70},
{0x38,0x00003ce8},
{0x3c,0x00003d60},
{0x40,0x00003dd8},
{0x44,0x00003f68},
{0x48,0x00004250},
{0x4c,0x00004608},
{0x50,0x0000469c},
{0x54,0x00004700},
{0x58,0x00004874},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0x1f},
{0x00,0x00000000},
{0x04,0x00000000},
{0x08,0x00000000},
{0x0c,0x00000000},
{0x10,0x00000000},
{0x14,0x00000000},
{0x18,0x00000000},
{0x1c,0x00000000},
{0x20,0x00000000},
{0x24,0x00000000},
{0x28,0x00000000},
{0x2c,0x00000000},
{0x30,0x00000000},
{0x34,0x00000000},
{0x38,0x00000000},
{0x3c,0x00002470},
{0x40,0x00002620},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x000026a0},
{0x50,0x00002760},
{0x54,0x00000000},
{0x58,0x00002810},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00002944},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00002a28},
{0x78,0x0000493c},
{0x7c,0x5a5a0ffc},
{0xf0,0x0},
{0x00,0x01000000},
{0x04,0x01000000},
{0x08,0x01000000},
{0x0c,0x233fc0c0},
{0x10,0xa2146004},
{0x14,0xa4102000},
{0x18,0xe4244000},
{0x1c,0x233fc0c0},
{0x20,0xa2146010},
{0x24,0x2500003f},
{0x28,0xa414a3ff},
{0x2c,0xe4244000},
{0x30,0x01000000},
{0x34,0x821020e0},
{0x38,0x81880001},
{0x3c,0x01000000},
{0x40,0x01000000},
{0x44,0xa410200f},
{0x48,0xe4a00040},
{0x4c,0x01000000},
{0x50,0xa0100000},
{0x54,0xa2100000},
{0x58,0xa4100000},
{0x5c,0xa6100000},
{0x60,0xa8100000},
{0x64,0xaa100000},
{0x68,0xac100000},
{0x6c,0xae100000},
{0x70,0x90100000},
{0x74,0x92100000},
{0x78,0x94100000},
{0x7c,0x96100000},
{0xf0,0x1},
{0x00,0x98100000},
{0x04,0x9a100000},
{0x08,0x9c100000},
{0x0c,0x9e100000},
{0x10,0x84100000},
{0x14,0x01000000},
{0x18,0x01000000},
{0x1c,0x82100000},
{0x20,0x81900001},
{0x24,0x82100000},
{0x28,0x81980001},
{0x2c,0x81800000},
{0x30,0x01000000},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0xbc102cfc},
{0x40,0x9c102cf8},
{0x44,0x01000000},
{0x48,0x01000000},
{0x4c,0x27001040},
{0x50,0xa614e00f},
{0x54,0xe6a00040},
{0x58,0x01000000},
{0x5c,0x40000309},
{0x60,0x01000000},
{0x64,0x01000000},
{0x68,0x10bfffff},
{0x6c,0x01000000},
{0x70,0x03169684},
{0x74,0x82106053},
{0x78,0x0329694d},
{0x7c,0x82106270},
{0xf0,0x1a},
{0x00,0x9de3bf98},
{0x04,0x40000010},
{0x08,0x01000000},
{0x0c,0x40000007},
{0x10,0x01000000},
{0x14,0x40000334},
{0x18,0x01000000},
{0x1c,0x40000015},
{0x20,0x01000000},
{0x24,0x30bffffe},
{0x28,0x82102001},
{0x2c,0x81904000},
{0x30,0x01000000},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0x81c3e008},
{0x40,0x01000000},
{0x44,0x03000008},
{0x48,0x82106342},
{0x4c,0xa3804000},
{0x50,0x03000004},
{0x54,0x82106000},
{0x58,0x81984000},
{0x5c,0x01000000},
{0x60,0x01000000},
{0x64,0x01000000},
{0x68,0x81c3e008},
{0x6c,0x01000000},
{0x70,0x01000000},
{0x74,0x01000000},
{0x78,0x01000000},
{0x7c,0xa7800000},
{0xf0,0x1b},
{0x00,0x01000000},
{0x04,0x01000000},
{0x08,0x01000000},
{0x0c,0x81c3e008},
{0x10,0x01000000},
{0x14,0x80a22000},
{0x18,0x02800006},
{0x1c,0x01000000},
{0x20,0x01000000},
{0x24,0x90823fff},
{0x28,0x12bffffe},
{0x2c,0x01000000},
{0x30,0x81c3e008},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0x05001040},
{0x40,0x8410a00f},
{0x44,0xc4a00040},
{0x48,0x01000000},
{0x4c,0x81c3e008},
{0x50,0x01000000},
{0x54,0x9de3bec8},
{0x58,0xb2067fff},
{0x5c,0x96100018},
{0x60,0xf227bf2c},
{0x64,0xc027bf28},
{0x68,0x98102000},
{0x6c,0xb007bff8},
{0x70,0xd4063f30},
{0x74,0xda063f34},
{0x78,0xb810000a},
{0x7c,0x98033fff},
{0xf0,0x1c},
{0x00,0xb0063ff8},
{0x04,0x80a2800d},
{0x08,0x16800031},
{0x0c,0xb610000d},
{0x10,0xbb2aa002},
{0x14,0x832b6002},
{0x18,0xb207400b},
{0x1c,0xb400400b},
{0x20,0xde02c01d},
{0x24,0x80a7001b},
{0x28,0x1680001c},
{0x2c,0x01000000},
{0x30,0xc2068000},
{0x34,0x80a0400f},
{0x38,0x04800005},
{0x3c,0x80a7001b},
{0x40,0xb606ffff},
{0x44,0x10bffff8},
{0x48,0xb406bffc},
{0x4c,0x16800013},
{0x50,0x80a7001b},
{0x54,0xc2068000},
{0x58,0xc2264000},
{0x5c,0xb8072001},
{0x60,0x80a7001b},
{0x64,0x1680000d},
{0x68,0xb2066004},
{0x6c,0xc2064000},
{0x70,0x80a0400f},
{0x74,0x26bffffb},
{0x78,0xb8072001},
{0x7c,0x80a7001b},
{0xf0,0x1d},
{0x00,0x16800006},
{0x04,0x01000000},
{0x08,0xc2268000},
{0x0c,0xb606ffff},
{0x10,0xb406bffc},
{0x14,0x80a7001b},
{0x18,0x12bfffe4},
{0x1c,0x80a7001b},
{0x20,0xb0062008},
{0x24,0x82073fff},
{0x28,0xc2263f34},
{0x2c,0xd4263f30},
{0x30,0x832f2002},
{0x34,0xb0062008},
{0x38,0xde22c001},
{0x3c,0xba072001},
{0x40,0xfa263f30},
{0x44,0xda263f34},
{0x48,0x98032002},
{0x4c,0x80a33fff},
{0x50,0x34bfffc9},
{0x54,0xd4063f30},
{0x58,0x81c7e008},
{0x5c,0x81e80000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0x20},
{0x00,0x83580000},
{0x04,0x82086ff0},
{0x08,0x83306004},
{0x0c,0x80a06005},
{0x10,0x02800027},
{0x14,0x01000000},
{0x18,0x80a06006},
{0x1c,0x0280003c},
{0x20,0x01000000},
{0x24,0x80a06015},
{0x28,0x02800054},
{0x2c,0x01000000},
{0x30,0x80a0602a},
{0x34,0x02800090},
{0x38,0x01000000},
{0x3c,0x80a06018},
{0x40,0x02800085},
{0x44,0x01000000},
{0x48,0x073fc180},
{0x4c,0x8610e03c},
{0x50,0x05169680},
{0x54,0x84004002},
{0x58,0xc420c000},
{0x5c,0x073fc000},
{0x60,0x8610e020},
{0x64,0x84102001},
{0x68,0xc420c000},
{0x6c,0x0500000c},
{0x70,0x01000000},
{0x74,0x01000000},
{0x78,0x8480bfff},
{0x7c,0x12bffffe},
{0xf0,0x21},
{0x00,0x01000000},
{0x04,0x01000000},
{0x08,0x073fc000},
{0x0c,0x8610e020},
{0x10,0x84102000},
{0x14,0xc420c000},
{0x18,0x01000000},
{0x1c,0x01000000},
{0x20,0x81c44000},
{0x24,0x81cc8000},
{0x28,0x01000000},
{0x2c,0xa7500000},
{0x30,0xa92ce002},
{0x34,0xa734e001},
{0x38,0xa614c014},
{0x3c,0xa60ce007},
{0x40,0x81900000},
{0x44,0x01000000},
{0x48,0x01000000},
{0x4c,0x81e00000},
{0x50,0xe03ba000},
{0x54,0xe43ba008},
{0x58,0xe83ba010},
{0x5c,0xec3ba018},
{0x60,0xf03ba020},
{0x64,0xf43ba028},
{0x68,0xf83ba030},
{0x6c,0xfc3ba038},
{0x70,0x81e80000},
{0x74,0x8194c000},
{0x78,0x01000000},
{0x7c,0x01000000},
{0xf0,0x22},
{0x00,0x81c44000},
{0x04,0x81cc8000},
{0x08,0x01000000},
{0x0c,0xa7500000},
{0x10,0xa934e002},
{0x14,0xa72ce001},
{0x18,0xa614c014},
{0x1c,0xa60ce007},
{0x20,0x81900000},
{0x24,0x01000000},
{0x28,0x01000000},
{0x2c,0x81e80000},
{0x30,0x81e80000},
{0x34,0xe01ba000},
{0x38,0xe41ba008},
{0x3c,0xe81ba010},
{0x40,0xec1ba018},
{0x44,0xf01ba020},
{0x48,0xf41ba028},
{0x4c,0xf81ba030},
{0x50,0xfc1ba038},
{0x54,0x81e00000},
{0x58,0x81e00000},
{0x5c,0x8194c000},
{0x60,0x01000000},
{0x64,0x01000000},
{0x68,0x81c44000},
{0x6c,0x81cc8000},
{0x70,0x01000000},
{0x74,0x01000000},
{0x78,0x82102010},
{0x7c,0x273fc0c0},
{0xf0,0x23},
{0x00,0xa614e010},
{0x04,0xc224c000},
{0x08,0x01000000},
{0x0c,0x033fc0c0},
{0x10,0x82106004},
{0x14,0xa6102000},
{0x18,0xe6204000},
{0x1c,0x01000000},
{0x20,0x01000000},
{0x24,0x01000000},
{0x28,0xa6102020},
{0x2c,0x83480000},
{0x30,0x82104013},
{0x34,0x81884000},
{0x38,0x01000000},
{0x3c,0x4000043a},
{0x40,0x01000000},
{0x44,0x01000000},
{0x48,0x01000000},
{0x4c,0xa7500000},
{0x50,0xa934e002},
{0x54,0xa72ce001},
{0x58,0xa614c014},
{0x5c,0xa60ce007},
{0x60,0x81900000},
{0x64,0x01000000},
{0x68,0x81e80000},
{0x6c,0xe01ba000},
{0x70,0xe41ba008},
{0x74,0xe81ba010},
{0x78,0xec1ba018},
{0x7c,0xf01ba020},
{0xf0,0x24},
{0x00,0xf41ba028},
{0x04,0xf81ba030},
{0x08,0xfc1ba038},
{0x0c,0x81e00000},
{0x10,0x8194c000},
{0x14,0x01000000},
{0x18,0xa6102020},
{0x1c,0x83480000},
{0x20,0x82284013},
{0x24,0x81884000},
{0x28,0x01000000},
{0x2c,0x033fc0c0},
{0x30,0x82106004},
{0x34,0xa6103fff},
{0x38,0xe6204000},
{0x3c,0x01000000},
{0x40,0x01000000},
{0x44,0x01000000},
{0x48,0x81c44000},
{0x4c,0x81cc8000},
{0x50,0x01000000},
{0x54,0x82102080},
{0x58,0x273fc0c0},
{0x5c,0xa614e010},
{0x60,0xc224c000},
{0x64,0x01000000},
{0x68,0x81c44000},
{0x6c,0x81cc8000},
{0x70,0x01000000},
{0x74,0x81c48000},
{0x78,0x81cca004},
{0x7c,0x01000000},
{0xf0,0x25},
{0x00,0x033fc200},
{0x04,0xda0021fc},
{0x08,0x9210608c},
{0x0c,0x96106084},
{0x10,0x94106088},
{0x14,0x825a000d},
{0x18,0x80a36000},
{0x1c,0x02800003},
{0x20,0x82006800},
{0x24,0x9130600c},
{0x28,0x992a2010},
{0x2c,0x82022001},
{0x30,0x9b2a2004},
{0x34,0x83286010},
{0x38,0x9a03000d},
{0x3c,0xda22c000},
{0x40,0x82004008},
{0x44,0x82006002},
{0x48,0xd8228000},
{0x4c,0x81c3e008},
{0x50,0xc2224000},
{0x54,0x1b3fc140},
{0x58,0x82136048},
{0x5c,0xc2104000},
{0x60,0x82006003},
{0x64,0x82086003},
{0x68,0x83286002},
{0x6c,0x9a136080},
{0x70,0x81c3e008},
{0x74,0xd000400d},
{0x78,0x94102000},
{0x7c,0x96102000},
{0xf0,0x26},
{0x00,0x832ae002},
{0x04,0xd20063a4},
{0x08,0x98102000},
{0x0c,0x832b2002},
{0x10,0x9b2aa002},
{0x14,0xda02000d},
{0x18,0x98032001},
{0x1c,0xda224001},
{0x20,0x80a32005},
{0x24,0x04bffffa},
{0x28,0x9402a001},
{0x2c,0x9602e001},
{0x30,0x80a2e003},
{0x34,0x04bffff4},
{0x38,0x832ae002},
{0x3c,0x81c3e008},
{0x40,0x01000000},
{0x44,0x82020008},
{0x48,0x82004008},
{0x4c,0x9b326002},
{0x50,0x82004001},
{0x54,0x8200400d},
{0x58,0x83286002},
{0x5c,0x920a6003},
{0x60,0x932a6003},
{0x64,0xd00065b0},
{0x68,0x91320009},
{0x6c,0x81c3e008},
{0x70,0x900a20ff},
{0x74,0x9a020008},
{0x78,0x9a034008},
{0x7c,0x97326002},
{0xf0,0x27},
{0x00,0x9a03400d},
{0x04,0x9a03400b},
{0x08,0x920a6003},
{0x0c,0x9b2b6002},
{0x10,0x932a6003},
{0x14,0x821020ff},
{0x18,0xd80365b0},
{0x1c,0x83284009},
{0x20,0x822b0001},
{0x24,0x952a8009},
{0x28,0x8210400a},
{0x2c,0xc22365b0},
{0x30,0x912a2002},
{0x34,0xda0223a4},
{0x38,0x972ae002},
{0x3c,0x81c3e008},
{0x40,0xc223400b},
{0x44,0x9a102005},
{0x48,0x8210200b},
{0x4c,0x9a234008},
{0x50,0x82204008},
{0x54,0x9b2b6002},
{0x58,0x80a22005},
{0x5c,0x14800007},
{0x60,0x99286002},
{0x64,0x033fc200},
{0x68,0x8210600c},
{0x6c,0xc2004000},
{0x70,0x10800006},
{0x74,0x8330400d},
{0x78,0x033fc200},
{0x7c,0x82106008},
{0xf0,0x28},
{0x00,0xc2004000},
{0x04,0x8330400c},
{0x08,0x81c3e008},
{0x0c,0x9008600f},
{0x10,0x9de3bf30},
{0x14,0xa12e2002},
{0x18,0xda1423da},
{0x1c,0xd61423d8},
{0x20,0xc200247c},
{0x24,0xb022c00d},
{0x28,0x825b4001},
{0x2c,0xb21e6001},
{0x30,0x92862001},
{0x34,0x0280000c},
{0x38,0x9a004019},
{0x3c,0xb0100009},
{0x40,0x9807bf90},
{0x44,0x8203400d},
{0x48,0xc2168001},
{0x4c,0xc2230000},
{0x50,0xc200247c},
{0x54,0x9a034001},
{0x58,0xb0863fff},
{0x5c,0x12bffffa},
{0x60,0x98032004},
{0x64,0x7ffffe5c},
{0x68,0x9007bf90},
{0x6c,0xda1423ea},
{0x70,0xd61423e8},
{0x74,0x80a3400b},
{0x78,0x92102000},
{0x7c,0x1880000b},
{0xf0,0x29},
{0x00,0xb010000d},
{0x04,0x832b6002},
{0x08,0x8200401e},
{0x0c,0x98007f90},
{0x10,0xc2030000},
{0x14,0xb0062001},
{0x18,0x92024001},
{0x1c,0x80a6000b},
{0x20,0x08bffffc},
{0x24,0x98032004},
{0x28,0xb022c00d},
{0x2c,0xb0062001},
{0x30,0x81800000},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0x01000000},
{0x40,0xb0724018},
{0x44,0x81c7e008},
{0x48,0x81e80000},
{0x4c,0x033fc200},
{0x50,0x961060a0},
{0x54,0x98102000},
{0x58,0x832b2002},
{0x5c,0x9a03000c},
{0x60,0xda136400},
{0x64,0x98032001},
{0x68,0x80a32019},
{0x6c,0x04bffffb},
{0x70,0xda20400b},
{0x74,0x81c3e008},
{0x78,0x01000000},
{0x7c,0x9de3bf98},
{0xf0,0x2a},
{0x00,0xc200247c},
{0x04,0x83306001},
{0x08,0x80a60001},
{0x0c,0x1a800006},
{0x10,0x90100018},
{0x14,0x7fffffac},
{0x18,0x01000000},
{0x1c,0x10800006},
{0x20,0xb0020008},
{0x24,0x7fffffa8},
{0x28,0x90260001},
{0x2c,0x90020008},
{0x30,0xb0022001},
{0x34,0x81c7e008},
{0x38,0x81e80000},
{0x3c,0x9de3bf98},
{0x40,0xa6102000},
{0x44,0xc20023d4},
{0x48,0x80a4c001},
{0x4c,0x1a800059},
{0x50,0xe2002348},
{0x54,0xaa102000},
{0x58,0xc200247c},
{0x5c,0x80a54001},
{0x60,0x3a800050},
{0x64,0xa604e001},
{0x68,0xa92ce002},
{0x6c,0x03000018},
{0x70,0x821060e0},
{0x74,0xae050001},
{0x78,0x7fffffe1},
{0x7c,0x90100015},
{0xf0,0x2b},
{0x00,0xac100008},
{0x04,0x90100013},
{0x08,0x7fffff6f},
{0x0c,0x92100016},
{0x10,0x80a62000},
{0x14,0x12800004},
{0x18,0xa0100008},
{0x1c,0x1080000b},
{0x20,0xa0102000},
{0x24,0x7fffff4c},
{0x28,0x01000000},
{0x2c,0x94100008},
{0x30,0x90100013},
{0x34,0x7fffff97},
{0x38,0x92100015},
{0x3c,0x80a62007},
{0x40,0x1880000f},
{0x44,0xa4100008},
{0x48,0x80a48011},
{0x4c,0x04800008},
{0x50,0x9a102007},
{0x54,0x9a102008},
{0x58,0x9a234018},
{0x5c,0x82102001},
{0x60,0x8328400d},
{0x64,0xa02c0001},
{0x68,0x9a102007},
{0x6c,0x9a234018},
{0x70,0x82102001},
{0x74,0x8328400d},
{0x78,0xa0140001},
{0x7c,0x80a62009},
{0xf0,0x2c},
{0x00,0x0280000b},
{0x04,0x821e2008},
{0x08,0x80a00001},
{0x0c,0x9a603fff},
{0x10,0x80a48011},
{0x14,0x14800003},
{0x18,0x82102001},
{0x1c,0x82102000},
{0x20,0x808b4001},
{0x24,0x0280000f},
{0x28,0x80a62008},
{0x2c,0xc205c000},
{0x30,0x80a04011},
{0x34,0x18800003},
{0x38,0x9a204011},
{0x3c,0x9a244001},
{0x40,0x80a48011},
{0x44,0x14800003},
{0x48,0x82248011},
{0x4c,0x82244012},
{0x50,0x80a34001},
{0x54,0xa0642000},
{0x58,0x10800007},
{0x5c,0xa4102000},
{0x60,0x32800006},
{0x64,0xe425c000},
{0x68,0x80a420fe},
{0x6c,0x24800002},
{0x70,0xa0042001},
{0x74,0xe425c000},
{0x78,0x92100016},
{0x7c,0x94100010},
{0xf0,0x2d},
{0x00,0x7fffff3d},
{0x04,0x90100013},
{0x08,0xaa056001},
{0x0c,0xc200247c},
{0x10,0x80a54001},
{0x14,0x0abfffb6},
{0x18,0xa8052010},
{0x1c,0xa604e001},
{0x20,0xc20023d4},
{0x24,0x80a4c001},
{0x28,0x0abfffac},
{0x2c,0xaa102000},
{0x30,0x81c7e008},
{0x34,0x81e80000},
{0x38,0x98102000},
{0x3c,0x9610201e},
{0x40,0x80a22000},
{0x44,0x12800003},
{0x48,0x8210000c},
{0x4c,0x8222c00c},
{0x50,0x83286002},
{0x54,0xda006480},
{0x58,0x80a37ff0},
{0x5c,0x02800006},
{0x60,0x98032002},
{0x64,0xc2006484},
{0x68,0x80a3201f},
{0x6c,0x04bffff5},
{0x70,0xc2234000},
{0x74,0x81c3e008},
{0x78,0x01000000},
{0x7c,0x9de3bf98},
{0xf0,0x2e},
{0x00,0xda002508},
{0x04,0x033fc000},
{0x08,0x9a0b4001},
{0x0c,0x173fc180},
{0x10,0x03202020},
{0x14,0x82106080},
{0x18,0x9812e038},
{0x1c,0xc2230000},
{0x20,0x03168000},
{0x24,0x80a34001},
{0x28,0xc022c000},
{0x2c,0xa6102000},
{0x30,0x1280000b},
{0x34,0xa8102000},
{0x38,0x0300003f},
{0x3c,0xda002548},
{0x40,0x821063ff},
{0x44,0x9a0b4001},
{0x48,0xd8002508},
{0x4c,0x033fffc0},
{0x50,0x980b0001},
{0x54,0x9a13400c},
{0x58,0xda202548},
{0x5c,0x80a62000},
{0x60,0x1680002b},
{0x64,0x1b296956},
{0x68,0x1b3fc040},
{0x6c,0xc2002548},
{0x70,0x8208400d},
{0x74,0x1b168040},
{0x78,0x80a0400d},
{0x7c,0x22800002},
{0xf0,0x2f},
{0x00,0xa6102001},
{0x04,0xda002654},
{0x08,0xc20021dc},
{0x0c,0x80a34001},
{0x10,0x1a80001f},
{0x14,0x1b296956},
{0x18,0x031696a9},
{0x1c,0xda00250c},
{0x20,0x821061a5},
{0x24,0x80a34001},
{0x28,0x02800006},
{0x2c,0x03296956},
{0x30,0x8210625a},
{0x34,0x80a34001},
{0x38,0x12800015},
{0x3c,0x1b296956},
{0x40,0xc200254c},
{0x44,0x80886004},
{0x48,0x32800002},
{0x4c,0xa8102001},
{0x50,0x11000016},
{0x54,0x13000017},
{0x58,0x90122330},
{0x5c,0x40000156},
{0x60,0x92126208},
{0x64,0x03000018},
{0x68,0x96106260},
{0x6c,0x98102000},
{0x70,0x9b2b2002},
{0x74,0x98032001},
{0x78,0xc20365b0},
{0x7c,0x80a32017},
{0xf0,0x30},
{0x00,0x08bffffc},
{0x04,0xc223400b},
{0x08,0x1b296956},
{0x0c,0x80a00013},
{0x10,0x82380018},
{0x14,0xa413625a},
{0x18,0x92402000},
{0x1c,0x8330601f},
{0x20,0x1b1696a9},
{0x24,0xa21361a5},
{0x28,0x90104009},
{0x2c,0xde00254c},
{0x30,0xe0002548},
{0x34,0x98102500},
{0x38,0xc200250c},
{0x3c,0x96033a50},
{0x40,0x941b250c},
{0x44,0x80a04012},
{0x48,0x02800007},
{0x4c,0x9a184011},
{0x50,0x80a0000d},
{0x54,0x82603fff},
{0x58,0x80904009},
{0x5c,0x0280000a},
{0x60,0x80a22000},
{0x64,0x80a2e0e0},
{0x68,0x9a402000},
{0x6c,0x80a0000a},
{0x70,0x82603fff},
{0x74,0x80934001},
{0x78,0x3280000a},
{0x7c,0x98032004},
{0xf0,0x31},
{0x00,0x80a22000},
{0x04,0x02800005},
{0x08,0x82033970},
{0x0c,0x80a0603f},
{0x10,0x28800004},
{0x14,0x98032004},
{0x18,0xc0230000},
{0x1c,0x98032004},
{0x20,0x80a32867},
{0x24,0x28bfffe6},
{0x28,0xc200250c},
{0x2c,0x80a62000},
{0x30,0x06800006},
{0x34,0x0300003f},
{0x38,0x821063ff},
{0x3c,0x820bc001},
{0x40,0x10800006},
{0x44,0xc220254c},
{0x48,0xc21022d4},
{0x4c,0x83286010},
{0x50,0xc2202690},
{0x54,0x80a62000},
{0x58,0x36800008},
{0x5c,0xc2002548},
{0x60,0xc200254c},
{0x64,0x9a050014},
{0x68,0x82087ffd},
{0x6c,0x8210400d},
{0x70,0xc220254c},
{0x74,0xc2002548},
{0x78,0xd8002334},
{0x7c,0xda0023c8},
{0xf0,0x32},
{0x00,0x98032001},
{0x04,0x92087dff},
{0x08,0x9b336012},
{0x0c,0x9a0b6200},
{0x10,0x83332001},
{0x14,0x9212400d},
{0x18,0x113fc200},
{0x1c,0x82030001},
{0x20,0xda002344},
{0x24,0x96122030},
{0x28,0xc220258c},
{0x2c,0xda22c000},
{0x30,0x95342018},
{0x34,0xda20257c},
{0x38,0x80a2a05a},
{0x3c,0xd8202554},
{0x40,0xd8202588},
{0x44,0xd2202548},
{0x48,0x12800009},
{0x4c,0xda202570},
{0x50,0x0300003f},
{0x54,0x821063ff},
{0x58,0x1b3fffc0},
{0x5c,0x820a4001},
{0x60,0x9a0c000d},
{0x64,0x8210400d},
{0x68,0xc2202548},
{0x6c,0x80a4e001},
{0x70,0x1280000c},
{0x74,0x03296956},
{0x78,0xc2002548},
{0x7c,0x83306012},
{0xf0,0x33},
{0x00,0x80886001},
{0x04,0x32800010},
{0x08,0x82102029},
{0x0c,0x9a122074},
{0x10,0xc2002330},
{0x14,0xc2234000},
{0x18,0x1080000b},
{0x1c,0x82102029},
{0x20,0xda00250c},
{0x24,0x8210625a},
{0x28,0x80a34001},
{0x2c,0x1280000b},
{0x30,0x01000000},
{0x34,0xc200254c},
{0x38,0x80886002},
{0x3c,0x12800007},
{0x40,0x82102015},
{0x44,0xc2202500},
{0x48,0x7ffffe4c},
{0x4c,0x901025b0},
{0x50,0x7ffffebf},
{0x54,0x81e80000},
{0x58,0x01000000},
{0x5c,0x81c7e008},
{0x60,0x81e80000},
{0x64,0x9de3bf98},
{0x68,0x40000213},
{0x6c,0x90102000},
{0x70,0x213fc140},
{0x74,0xda00247c},
{0x78,0x98142040},
{0x7c,0xfa030000},
{0xf0,0x34},
{0x00,0xc20022f8},
{0x04,0x9b336001},
{0x08,0x825b4001},
{0x0c,0xba0f7800},
{0x10,0xba174001},
{0x14,0xfa230000},
{0x18,0x82142004},
{0x1c,0xfa004000},
{0x20,0xba0f7fe0},
{0x24,0x393fc200},
{0x28,0xba17400d},
{0x2c,0xfa204000},
{0x30,0x94172080},
{0x34,0xfa028000},
{0x38,0xba0f7fe0},
{0x3c,0xba17400d},
{0x40,0x033fc0c0},
{0x44,0xfa228000},
{0x48,0xb6106004},
{0x4c,0xc2002298},
{0x50,0x9a172070},
{0x54,0xc2234000},
{0x58,0x033fc000},
{0x5c,0xda002338},
{0x60,0x82106030},
{0x64,0xda204000},
{0x68,0xc200232c},
{0x6c,0x9e172074},
{0x70,0xc223c000},
{0x74,0x0300003f},
{0x78,0xa6142058},
{0x7c,0x821063ff},
{0xf0,0x35},
{0x00,0x17000015},
{0x04,0xc224c000},
{0x08,0x9612e180},
{0x0c,0x92142088},
{0x10,0x19000016},
{0x14,0xd6224000},
{0x18,0x98132058},
{0x1c,0x9014208c},
{0x20,0xd8220000},
{0x24,0xc20023f8},
{0x28,0xa217200c},
{0x2c,0xc2244000},
{0x30,0xc20023fc},
{0x34,0x35200040},
{0x38,0xa4172008},
{0x3c,0xc2248000},
{0x40,0xae16a101},
{0x44,0xee270000},
{0x48,0xa814205c},
{0x4c,0xc0250000},
{0x50,0xaa142080},
{0x54,0xd6254000},
{0x58,0xac142084},
{0x5c,0xd8258000},
{0x60,0x7ffffe7b},
{0x64,0xc026c000},
{0x68,0x9a17207c},
{0x6c,0xfa034000},
{0x70,0x033ff000},
{0x74,0xba2f4001},
{0x78,0xfa234000},
{0x7c,0x033fc1c0},
{0xf0,0x36},
{0x00,0xda002340},
{0x04,0x82106064},
{0x08,0xda204000},
{0x0c,0x0300007f},
{0x10,0x96142010},
{0x14,0x821063ff},
{0x18,0xc222c000},
{0x1c,0x1907ffc0},
{0x20,0x94142030},
{0x24,0xd8228000},
{0x28,0xa0142014},
{0x2c,0xd8240000},
{0x30,0x7ffffdd4},
{0x34,0xd0002374},
{0x38,0x173fc080},
{0x3c,0xc2002174},
{0x40,0x90103fff},
{0x44,0x80a06000},
{0x48,0x02800006},
{0x4c,0x9812e008},
{0x50,0xc2082174},
{0x54,0xda082177},
{0x58,0xc2230000},
{0x5c,0xda22c000},
{0x60,0x7ffffee7},
{0x64,0x01000000},
{0x68,0x7ffffed4},
{0x6c,0x90102001},
{0x70,0x82103fff},
{0x74,0xc226c000},
{0x78,0xf4270000},
{0x7c,0x81c7e008},
{0xf0,0x37},
{0x00,0x81e80000},
{0x04,0x9de3bf98},
{0x08,0xc2002508},
{0x0c,0x808860ff},
{0x10,0x0280001c},
{0x14,0x01000000},
{0x18,0xc2002508},
{0x1c,0x820860ff},
{0x20,0x80a04018},
{0x24,0x213c0000},
{0x28,0x12800014},
{0x2c,0x033fc180},
{0x30,0x7ffffc82},
{0x34,0x01000000},
{0x38,0x1b002000},
{0x3c,0x033fc180},
{0x40,0x9a2c000d},
{0x44,0x82106034},
{0x48,0xda204000},
{0x4c,0x033fc040},
{0x50,0x8210600c},
{0x54,0x1100000a},
{0x58,0xc0204000},
{0x5c,0x7ffffc6e},
{0x60,0x90122104},
{0x64,0xc2002508},
{0x68,0x820860ff},
{0x6c,0x80a04018},
{0x70,0x10bfffee},
{0x74,0xa0042001},
{0x78,0x8210603c},
{0x7c,0xc0204000},
{0xf0,0x38},
{0x00,0x81c7e008},
{0x04,0x81e80000},
{0x08,0x9a102000},
{0x0c,0x832b6002},
{0x10,0x9a036001},
{0x14,0x80a360b5},
{0x18,0x08bffffd},
{0x1c,0xc0220001},
{0x20,0x81c3e008},
{0x24,0x01000000},
{0x28,0xc20022f8},
{0x2c,0xda00247c},
{0x30,0x8258400d},
{0x34,0x83306001},
{0x38,0x96102000},
{0x3c,0x80a2c001},
{0x40,0x1a80003b},
{0x44,0x0300003f},
{0x48,0x941063ff},
{0x4c,0x98102000},
{0x50,0x80a26001},
{0x54,0x0280002e},
{0x58,0x80a26004},
{0x5c,0x12800008},
{0x60,0x80a26008},
{0x64,0xc2030008},
{0x68,0x9a08400a},
{0x6c,0x83306012},
{0x70,0x83286010},
{0x74,0x10800014},
{0x78,0x9b336002},
{0x7c,0x28800015},
{0xf0,0x39},
{0x00,0xda02000c},
{0x04,0xda030008},
{0x08,0x83336010},
{0x0c,0x82004001},
{0x10,0x9a0b400a},
{0x14,0x81800000},
{0x18,0x01000000},
{0x1c,0x01000000},
{0x20,0x01000000},
{0x24,0x82704009},
{0x28,0x9a03400d},
{0x2c,0x83286010},
{0x30,0x81800000},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0x01000000},
{0x40,0x9a734009},
{0x44,0x8200400d},
{0x48,0x10800011},
{0x4c,0xc2230008},
{0x50,0x83336010},
{0x54,0x81800000},
{0x58,0x01000000},
{0x5c,0x01000000},
{0x60,0x01000000},
{0x64,0x82704009},
{0x68,0x9a0b400a},
{0x6c,0x83286010},
{0x70,0x81800000},
{0x74,0x01000000},
{0x78,0x01000000},
{0x7c,0x01000000},
{0xf0,0x3a},
{0x00,0x9a734009},
{0x04,0x8200400d},
{0x08,0xc222000c},
{0x0c,0xc20022f8},
{0x10,0xda00247c},
{0x14,0x8258400d},
{0x18,0x9602e001},
{0x1c,0x83306001},
{0x20,0x80a2c001},
{0x24,0x0abfffcb},
{0x28,0x98032004},
{0x2c,0x81c3e008},
{0x30,0x01000000},
{0x34,0x98102000},
{0x38,0x9b2b2002},
{0x3c,0x98032001},
{0x40,0xc202000d},
{0x44,0x80a320b5},
{0x48,0x04bffffc},
{0x4c,0xc222400d},
{0x50,0x81c3e008},
{0x54,0x01000000},
{0x58,0xd6020000},
{0x5c,0xd8024000},
{0x60,0x9132e010},
{0x64,0x95332010},
{0x68,0x900a2fff},
{0x6c,0x940aafff},
{0x70,0x03000007},
{0x74,0x9a22000a},
{0x78,0x821063ff},
{0x7c,0x940b0001},
{0xf0,0x3b},
{0x00,0x900ac001},
{0x04,0x9022000a},
{0x08,0x9a5b400d},
{0x0c,0x905a0008},
{0x10,0x81c3e008},
{0x14,0x90034008},
{0x18,0x9de3bf88},
{0x1c,0x832e6004},
{0x20,0x82004018},
{0x24,0x3b000018},
{0x28,0xba1760e0},
{0x2c,0x83286002},
{0x30,0xf400401d},
{0x34,0x033fc000},
{0x38,0x82106001},
{0x3c,0xc227bfe8},
{0x40,0x03000040},
{0x44,0xc227bfec},
{0x48,0x033fc040},
{0x4c,0x821061fe},
{0x50,0xc227bff0},
{0x54,0x0300bf80},
{0x58,0x82106101},
{0x5c,0xc227bff4},
{0x60,0x9e10001d},
{0x64,0xb6102000},
{0x68,0x9a07bff8},
{0x6c,0xba06c00d},
{0x70,0xc24f7ff0},
{0x74,0xb0060001},
{0x78,0xc24f7ff8},
{0x7c,0xb2064001},
{0xf0,0x3c},
{0x00,0x82067fff},
{0x04,0x82164001},
{0x08,0x80a62000},
{0x0c,0x0480001c},
{0x10,0xbb30601f},
{0x14,0xc2002308},
{0x18,0x80a04018},
{0x1c,0x82402000},
{0x20,0x8090401d},
{0x24,0x32800017},
{0x28,0xb606e001},
{0x2c,0xc2002300},
{0x30,0x80a64001},
{0x34,0x18800012},
{0x38,0xbb2e6004},
{0x3c,0x82074018},
{0x40,0x80a6e003},
{0x44,0x14800008},
{0x48,0xb9286002},
{0x4c,0xc207000f},
{0x50,0x80a0401a},
{0x54,0x2680000b},
{0x58,0xb606e001},
{0x5c,0x1080000d},
{0x60,0xb0102000},
{0x64,0xc207000f},
{0x68,0x80a0401a},
{0x6c,0x24800005},
{0x70,0xb606e001},
{0x74,0x10800007},
{0x78,0xb0102000},
{0x7c,0xb606e001},
{0xf0,0x3d},
{0x00,0x80a6e007},
{0x04,0x04bfffdb},
{0x08,0xba06c00d},
{0x0c,0xb0102001},
{0x10,0x81c7e008},
{0x14,0x81e80000},
{0x18,0xc020255c},
{0x1c,0xc0202514},
{0x20,0x9a102000},
{0x24,0x832b6002},
{0x28,0x9a036001},
{0x2c,0xc0206738},
{0x30,0x80a36009},
{0x34,0x04bffffc},
{0x38,0xc0206710},
{0x3c,0x81c3e008},
{0x40,0x01000000},
{0x44,0x9de3bf88},
{0x48,0x82063fff},
{0x4c,0xb8067fff},
{0x50,0x82160001},
{0x54,0xba16401c},
{0x58,0x80974001},
{0x5c,0xa410001a},
{0x60,0x0680007c},
{0x64,0xa210001b},
{0x68,0xc2002308},
{0x6c,0x80a60001},
{0x70,0x38800079},
{0x74,0xb0102000},
{0x78,0xc2002300},
{0x7c,0x80a64001},
{0xf0,0x3e},
{0x00,0x38800075},
{0x04,0xb0102000},
{0x08,0x96062001},
{0x0c,0x98066001},
{0x10,0xa007bff8},
{0x14,0x8207bfe8},
{0x18,0xb0102003},
{0x1c,0xc0204000},
{0x20,0xb0863fff},
{0x24,0x1cbffffe},
{0x28,0x82006004},
{0x2c,0xc2002160},
{0x30,0x80886004},
{0x34,0x0280000f},
{0x38,0xb0102004},
{0x3c,0x80a66001},
{0x40,0x0280000b},
{0x44,0x821021ff},
{0x48,0xc2002308},
{0x4c,0x80a60001},
{0x50,0x02800007},
{0x54,0x821021ff},
{0x58,0xc2002300},
{0x5c,0x80a64001},
{0x60,0x12800005},
{0x64,0x80a7000c},
{0x68,0x821021ff},
{0x6c,0xc227bff4},
{0x70,0x80a7000c},
{0x74,0x14800030},
{0x78,0xb210001c},
{0x7c,0x8207001c},
{0xf0,0x3f},
{0x00,0xba03000c},
{0x04,0xba07400c},
{0x08,0x8200401c},
{0x0c,0x8220401d},
{0x10,0x3b000018},
{0x14,0x901760e0},
{0x18,0x9a20400b},
{0x1c,0xb002fffe},
{0x20,0x832e6004},
{0x24,0x82004018},
{0x28,0x83286002},
{0x2c,0xba06000d},
{0x30,0xb4004008},
{0x34,0xb6076008},
{0x38,0x92102001},
{0x3c,0x952a401b},
{0x40,0x9e102000},
{0x44,0xb92be002},
{0x48,0xfa072520},
{0x4c,0xba5f4011},
{0x50,0x833f601f},
{0x54,0x83306018},
{0x58,0xba074001},
{0x5c,0xc2068000},
{0x60,0x82204012},
{0x64,0xbb3f6008},
{0x68,0x9e03e001},
{0x6c,0x80a0401d},
{0x70,0x04800005},
{0x74,0xb8070010},
{0x78,0xc2073ff0},
{0x7c,0x8210400a},
{0xf0,0x40},
{0x00,0xc2273ff0},
{0x04,0x80a3e003},
{0x08,0x08bffff0},
{0x0c,0xb92be002},
{0x10,0xb0062001},
{0x14,0xb606e001},
{0x18,0x80a6000b},
{0x1c,0x04bfffe8},
{0x20,0xb406a004},
{0x24,0xb2066001},
{0x28,0x80a6400c},
{0x2c,0x04bfffdc},
{0x30,0x9a036003},
{0x34,0xc207bfe8},
{0x38,0x80886010},
{0x3c,0x0280000a},
{0x40,0xfa07bfec},
{0x44,0xc207bff4},
{0x48,0x80886082},
{0x4c,0x02800007},
{0x50,0x808f6010},
{0x54,0x80886028},
{0x58,0x1280001f},
{0x5c,0xb0102003},
{0x60,0xfa07bfec},
{0x64,0x808f6010},
{0x68,0x02800012},
{0x6c,0xc207bff0},
{0x70,0x808f6082},
{0x74,0x02800007},
{0x78,0x808f6028},
{0x7c,0xc207bff4},
{0xf0,0x41},
{0x00,0x80886028},
{0x04,0x32800014},
{0x08,0xb0102002},
{0x0c,0x808f6028},
{0x10,0x02800008},
{0x14,0xc207bff0},
{0x18,0xc207bff4},
{0x1c,0x80886082},
{0x20,0x02800004},
{0x24,0xc207bff0},
{0x28,0x1080000b},
{0x2c,0xb0102002},
{0x30,0x80886010},
{0x34,0x02800008},
{0x38,0xb0102000},
{0x3c,0x80886082},
{0x40,0x02800005},
{0x44,0x80886028},
{0x48,0x12800003},
{0x4c,0xb0102001},
{0x50,0xb0102000},
{0x54,0x81c7e008},
{0x58,0x81e80000},
{0x5c,0x94102000},
{0x60,0xc2002514},
{0x64,0x80a28001},
{0x68,0x96102000},
{0x6c,0x1a80000e},
{0x70,0x9b2ae002},
{0x74,0xc2036710},
{0x78,0x9602e001},
{0x7c,0x80a06000},
{0xf0,0x42},
{0x00,0x02800006},
{0x04,0x992aa002},
{0x08,0xc2232710},
{0x0c,0xc2036738},
{0x10,0x9402a001},
{0x14,0xc2232738},
{0x18,0xc2002514},
{0x1c,0x10bffff4},
{0x20,0x80a2c001},
{0x24,0x81c3e008},
{0x28,0xd4202514},
{0x2c,0xd4020000},
{0x30,0x03000016},
{0x34,0x9802800a},
{0x38,0x82106330},
{0x3c,0xda530001},
{0x40,0xc2002590},
{0x44,0xc250400c},
{0x48,0x96a0400d},
{0x4c,0x02800016},
{0x50,0x03000016},
{0x54,0x80a2e000},
{0x58,0x04800009},
{0x5c,0x82102001},
{0x60,0xda022004},
{0x64,0x8328400d},
{0x68,0x80a2c001},
{0x6c,0x3480000d},
{0x70,0x973ac00d},
{0x74,0x1080000b},
{0x78,0x96102001},
{0x7c,0x1680000a},
{0xf0,0x43},
{0x00,0x03000016},
{0x04,0xda022008},
{0x08,0x82103fff},
{0x0c,0x8328400d},
{0x10,0x80a2c001},
{0x14,0x36800003},
{0x18,0x96103fff},
{0x1c,0x973ac00d},
{0x20,0x03000016},
{0x24,0x92106330},
{0x28,0x8202800a},
{0x2c,0xc2504009},
{0x30,0x9602c001},
{0x34,0x808aa001},
{0x38,0x0280000f},
{0x3c,0x9b3aa01f},
{0x40,0x9b33601f},
{0x44,0x9a02800d},
{0x48,0x9b3b6001},
{0x4c,0x9b2b6002},
{0x50,0xd8034009},
{0x54,0x033fffc0},
{0x58,0x980b0001},
{0x5c,0x0300003f},
{0x60,0x821063ff},
{0x64,0x820ac001},
{0x68,0x98030001},
{0x6c,0x1080000d},
{0x70,0xd8234009},
{0x74,0x9b33601f},
{0x78,0x9a02800d},
{0x7c,0x9b3b6001},
{0xf0,0x44},
{0x00,0x9b2b6002},
{0x04,0x0300003f},
{0x08,0xd8034009},
{0x0c,0x821063ff},
{0x10,0x980b0001},
{0x14,0x832ae010},
{0x18,0x8200400c},
{0x1c,0xc2234009},
{0x20,0xc2020000},
{0x24,0xda00247c},
{0x28,0x8200400d},
{0x2c,0x81c3e008},
{0x30,0xc2220000},
{0x34,0x9de3bf98},
{0x38,0x833e201f},
{0x3c,0xd0002320},
{0x40,0x82204018},
{0x44,0x80a22000},
{0x48,0x02800015},
{0x4c,0x9b30601f},
{0x50,0x033fc000},
{0x54,0xa0106020},
{0x58,0xc200231c},
{0x5c,0x80a00001},
{0x60,0x82402000},
{0x64,0x8088400d},
{0x68,0xc2002318},
{0x6c,0x02800009},
{0x70,0xb01e0001},
{0x74,0x80a00001},
{0x78,0x82603fff},
{0x7c,0x7ffffac6},
{0xf0,0x45},
{0x00,0xc2240000},
{0x04,0xc2002318},
{0x08,0x10800005},
{0x0c,0xc2240000},
{0x10,0x033fc000},
{0x14,0x82106020},
{0x18,0xf0204000},
{0x1c,0x81c7e008},
{0x20,0x81e80000},
{0x24,0x9de3bf98},
{0x28,0x7ffffac4},
{0x2c,0x01000000},
{0x30,0xe0002500},
{0x34,0x80a42028},
{0x38,0x08800013},
{0x3c,0x80a42000},
{0x40,0xc0202584},
{0x44,0xa2102000},
{0x48,0x832c6002},
{0x4c,0xc2006f04},
{0x50,0x80a06000},
{0x54,0x02800056},
{0x58,0xa2046001},
{0x5c,0x9fc04000},
{0x60,0x01000000},
{0x64,0xc2002584},
{0x68,0x80a06000},
{0x6c,0x12800050},
{0x70,0x80a4603b},
{0x74,0x24bffff6},
{0x78,0x832c6002},
{0x7c,0x1080004d},
{0xf0,0x46},
{0x00,0xc2002500},
{0x04,0x1280000d},
{0x08,0x80a42014},
{0x0c,0xc2002fcc},
{0x10,0x9fc04000},
{0x14,0x01000000},
{0x18,0x7ffffcf9},
{0x1c,0x90102000},
{0x20,0x7ffffce6},
{0x24,0x90102001},
{0x28,0xc200254c},
{0x2c,0x82087ffb},
{0x30,0x1080003f},
{0x34,0xc220254c},
{0x38,0x1880000c},
{0x3c,0x80a42015},
{0x40,0x808c2001},
{0x44,0x3280003b},
{0x48,0xc2002500},
{0x4c,0x90043ffe},
{0x50,0x7ffffc7b},
{0x54,0x91322001},
{0x58,0x7ffffc5d},
{0x5c,0x01000000},
{0x60,0x10800034},
{0x64,0xc2002500},
{0x68,0x18800011},
{0x6c,0x80a42018},
{0x70,0x033fc180},
{0x74,0xda0025b0},
{0x78,0x82106038},
{0x7c,0xda204000},
{0xf0,0x47},
{0x00,0x033fc200},
{0x04,0x82106074},
{0x08,0xda00232c},
{0x0c,0xda204000},
{0x10,0x7ffffcca},
{0x14,0x90102000},
{0x18,0xc200254c},
{0x1c,0x82106004},
{0x20,0xc220254c},
{0x24,0x10800020},
{0x28,0xc2002fcc},
{0x2c,0x1880000c},
{0x30,0x80a42028},
{0x34,0x90102000},
{0x38,0x92102000},
{0x3c,0xc2002fc0},
{0x40,0x9fc04000},
{0x44,0x94102000},
{0x48,0x11000016},
{0x4c,0x7ffffe0f},
{0x50,0x90122330},
{0x54,0x10800017},
{0x58,0xc2002500},
{0x5c,0x38800015},
{0x60,0xc2002500},
{0x64,0x7ffffbbc},
{0x68,0x23000016},
{0x6c,0x92146330},
{0x70,0xc2002fc0},
{0x74,0x9fc04000},
{0x78,0x94043fe8},
{0x7c,0x80a42028},
{0xf0,0x48},
{0x00,0x3280000c},
{0x04,0xc2002500},
{0x08,0x90146330},
{0x0c,0x7ffffe07},
{0x10,0x92102008},
{0x14,0xc2002fd8},
{0x18,0x80a06000},
{0x1c,0x22800005},
{0x20,0xc2002500},
{0x24,0x9fc04000},
{0x28,0x01000000},
{0x2c,0xc2002500},
{0x30,0x80a40001},
{0x34,0x1280000b},
{0x38,0x031fffff},
{0x3c,0x821063f0},
{0x40,0x80a40001},
{0x44,0x38800003},
{0x48,0x21040000},
{0x4c,0xa0042001},
{0x50,0x033fc180},
{0x54,0x82106034},
{0x58,0xe0204000},
{0x5c,0xe0202500},
{0x60,0x81c7e008},
{0x64,0x81e80000},
{0x68,0x81c3e008},
{0x6c,0x01000000},
{0x70,0x9de3bf60},
{0x74,0x1b00003f},
{0x78,0xc2002350},
{0x7c,0x9a1363ff},
{0xf0,0x49},
{0x00,0xae08400d},
{0x04,0xa6102001},
{0x08,0xda002300},
{0x0c,0x80a4c00d},
{0x10,0x18800062},
{0x14,0xa3306010},
{0x18,0xa4102010},
{0x1c,0xac102000},
{0x20,0xaa102000},
{0x24,0xa8102000},
{0x28,0x80a46000},
{0x2c,0x0280002c},
{0x30,0xa0102000},
{0x34,0x03000018},
{0x38,0x961060e0},
{0x3c,0x92102000},
{0x40,0x9807bfc0},
{0x44,0x82050009},
{0x48,0xda086440},
{0x4c,0x8204800d},
{0x50,0x80a36000},
{0x54,0x02800008},
{0x58,0x83286002},
{0x5c,0xc200400b},
{0x60,0xc2230000},
{0x64,0x92026001},
{0x68,0x80a2600b},
{0x6c,0x04bffff6},
{0x70,0x98032004},
{0x74,0x7ffffa38},
{0x78,0x9007bfc0},
{0x7c,0x80a5c011},
{0xf0,0x4a},
{0x00,0x1480000b},
{0x04,0x92100017},
{0x08,0x832de002},
{0x0c,0x8200401e},
{0x10,0x9a007fc0},
{0x14,0xc2034000},
{0x18,0x92026001},
{0x1c,0xa0040001},
{0x20,0x80a24011},
{0x24,0x04bffffc},
{0x28,0x9a036004},
{0x2c,0x82244017},
{0x30,0x82006001},
{0x34,0x9b3c201f},
{0x38,0x81836000},
{0x3c,0x01000000},
{0x40,0x01000000},
{0x44,0x01000000},
{0x48,0xa07c0001},
{0x4c,0xc25021ae},
{0x50,0x80a40001},
{0x54,0x26800002},
{0x58,0xa0100001},
{0x5c,0x03000018},
{0x60,0x941060e0},
{0x64,0x92102000},
{0x68,0x82054009},
{0x6c,0xda086440},
{0x70,0x8204800d},
{0x74,0x99286002},
{0x78,0x80a36000},
{0x7c,0x0280001d},
{0xf0,0x4b},
{0x00,0x9610000c},
{0x04,0x80a42000},
{0x08,0x2480000c},
{0x0c,0xc202c00a},
{0x10,0xc203000a},
{0x14,0x80a04010},
{0x18,0x16800007},
{0x1c,0x98102000},
{0x20,0x80a06000},
{0x24,0x24800006},
{0x28,0x98100001},
{0x2c,0x10800005},
{0x30,0x8204800d},
{0x34,0xc202c00a},
{0x38,0x98204010},
{0x3c,0x8204800d},
{0x40,0x9b286002},
{0x44,0xc20023c8},
{0x48,0x83306011},
{0x4c,0x80886001},
{0x50,0x02800005},
{0x54,0x92026001},
{0x58,0xc20ce2af},
{0x5c,0x825b0001},
{0x60,0x99386007},
{0x64,0x80a2600b},
{0x68,0x04bfffe0},
{0x6c,0xd823400a},
{0x70,0xac05a001},
{0x74,0xa805200c},
{0x78,0x80a5a001},
{0x7c,0x04bfffab},
{0xf0,0x4c},
{0x00,0xaa05600c},
{0x04,0xa604e001},
{0x08,0xc2002300},
{0x0c,0x80a4c001},
{0x10,0x08bfffa3},
{0x14,0xa404a010},
{0x18,0x81c7e008},
{0x1c,0x81e80000},
{0x20,0x9de3bf98},
{0x24,0x9e100018},
{0x28,0x80a66000},
{0x2c,0x0280001b},
{0x30,0xb010001a},
{0x34,0x031fffdf},
{0x38,0xb41063ff},
{0x3c,0x82102000},
{0x40,0xbb286002},
{0x44,0x80a62009},
{0x48,0xb6006001},
{0x4c,0x12800006},
{0x50,0xb810001d},
{0x54,0xc206401d},
{0x58,0x83306001},
{0x5c,0x8208401a},
{0x60,0xc226401d},
{0x64,0x80a62008},
{0x68,0x08800006},
{0x6c,0xc206401c},
{0x70,0xfa03c01c},
{0x74,0xbb376001},
{0x78,0x10800003},
{0x7c,0xba0f401a},
{0xf0,0x4d},
{0x00,0xfa03c01c},
{0x04,0x8200401d},
{0x08,0xc226401c},
{0x0c,0x80a6e0b5},
{0x10,0x08bfffec},
{0x14,0x8210001b},
{0x18,0x81c7e008},
{0x1c,0x81e80000},
{0x20,0x03169696},
{0x24,0xda002180},
{0x28,0x8210625a},
{0x2c,0x80a34001},
{0x30,0x94102000},
{0x34,0x12800006},
{0x38,0x96102000},
{0x3c,0x033fc180},
{0x40,0x82106030},
{0x44,0x10800024},
{0x48,0xda204000},
{0x4c,0xc202c000},
{0x50,0x9602e004},
{0x54,0x80a2e4ff},
{0x58,0x08bffffd},
{0x5c,0x94028001},
{0x60,0x96102d00},
{0x64,0xd2002ff8},
{0x68,0x03000019},
{0x6c,0x80a2c009},
{0x70,0x1a80000b},
{0x74,0x901063ff},
{0x78,0xd802c000},
{0x7c,0x9602e004},
{0xf0,0x4e},
{0x00,0x80a2c009},
{0x04,0x9a402000},
{0x08,0x80a2000b},
{0x0c,0x82603fff},
{0x10,0x808b4001},
{0x14,0x12bffff9},
{0x18,0x9402800c},
{0x1c,0xc20021fc},
{0x20,0x94228001},
{0x24,0xc2002200},
{0x28,0x94228001},
{0x2c,0x03169696},
{0x30,0x8210625a},
{0x34,0x80a28001},
{0x38,0x033fc180},
{0x3c,0x82106030},
{0x40,0x02800005},
{0x44,0xd4204000},
{0x48,0x03000008},
{0x4c,0x81c06234},
{0x50,0x90102001},
{0x54,0x01000000},
{0x58,0x81c3e008},
{0x5c,0x01000000},
{0x60,0x9de3bf98},
{0x64,0x9e100018},
{0x68,0x03000018},
{0x6c,0xb0100019},
{0x70,0xba1060e0},
{0x74,0xb6102000},
{0x78,0x832ee002},
{0x7c,0xb606e001},
{0xf0,0x4f},
{0x00,0x80a6e1bf},
{0x04,0x08bffffd},
{0x08,0xc020401d},
{0x0c,0xb6102000},
{0x10,0xc20022fc},
{0x14,0x80a6c001},
{0x18,0x1a80001c},
{0x1c,0x03000018},
{0x20,0xb2106124},
{0x24,0xb4102000},
{0x28,0xc20022f8},
{0x2c,0x80a68001},
{0x30,0x1a800011},
{0x34,0x832ee002},
{0x38,0xb8004019},
{0x3c,0xc200247c},
{0x40,0xfa0ee380},
{0x44,0x825e8001},
{0x48,0x8200401d},
{0x4c,0x82004001},
{0x50,0xfa160001},
{0x54,0xc213c001},
{0x58,0x8220401d},
{0x5c,0xc2270000},
{0x60,0xb406a001},
{0x64,0xc20022f8},
{0x68,0x80a68001},
{0x6c,0x0abffff4},
{0x70,0xb8072040},
{0x74,0xb606e001},
{0x78,0xc20022fc},
{0x7c,0x80a6c001},
{0xf0,0x50},
{0x00,0x0abfffea},
{0x04,0xb4102000},
{0x08,0x81c7e008},
{0x0c,0x81e80000},
{0x10,0x9de3bf98},
{0x14,0x11000016},
{0x18,0xc2002fe4},
{0x1c,0x9fc04000},
{0x20,0x90122330},
{0x24,0xc200259c},
{0x28,0xd800254c},
{0x2c,0x808b2002},
{0x30,0x02800034},
{0x34,0xc2202550},
{0x38,0xda002654},
{0x3c,0x8203400d},
{0x40,0x8200400d},
{0x44,0xda00259c},
{0x48,0xb20362d8},
{0x4c,0x82004001},
{0x50,0x9a102061},
{0x54,0x9a234001},
{0x58,0x832e6007},
{0x5c,0x9738601f},
{0x60,0x8182e000},
{0x64,0x01000000},
{0x68,0x01000000},
{0x6c,0x01000000},
{0x70,0xb278400d},
{0x74,0x980b3ffd},
{0x78,0x11000017},
{0x7c,0xd820254c},
{0xf0,0x51},
{0x00,0xc2002fe4},
{0x04,0x9fc04000},
{0x08,0x90122208},
{0x0c,0x11000014},
{0x10,0xe000259c},
{0x14,0xc2002fe4},
{0x18,0x9fc04000},
{0x1c,0x901222a8},
{0x20,0x80a64010},
{0x24,0x9a603fff},
{0x28,0xc200259c},
{0x2c,0x80a64001},
{0x30,0x82603fff},
{0x34,0x80934001},
{0x38,0x22800012},
{0x3c,0xc020250c},
{0x40,0x21000018},
{0x44,0x7ffffa8d},
{0x48,0x90142260},
{0x4c,0xa0142260},
{0x50,0xb2102000},
{0x54,0x9b2e6002},
{0x58,0xb2066001},
{0x5c,0xc2034010},
{0x60,0x80a66017},
{0x64,0x04bffffc},
{0x68,0xc22365b0},
{0x6c,0x7ffffaf8},
{0x70,0x01000000},
{0x74,0x82102015},
{0x78,0x10800010},
{0x7c,0xc2202500},
{0xf0,0x52},
{0x00,0xc200250c},
{0x04,0x80a06000},
{0x08,0x1280000c},
{0x0c,0x031696a9},
{0x10,0x821061a5},
{0x14,0x31000016},
{0x18,0x33000014},
{0x1c,0xc220250c},
{0x20,0xc0202658},
{0x24,0xc0202654},
{0x28,0xb0162330},
{0x2c,0xb21662a8},
{0x30,0x7ffffd01},
{0x34,0x81e80000},
{0x38,0x01000000},
{0x3c,0x81c7e008},
{0x40,0x81e80000},
{0x44,0x9de3bf30},
{0x48,0xc2102548},
{0x4c,0x80886001},
{0x50,0x94100018},
{0x54,0x9a102000},
{0x58,0x96102000},
{0x5c,0x02800004},
{0x60,0x98102000},
{0x64,0xc020259c},
{0x68,0x3080002e},
{0x6c,0x9e102000},
{0x70,0x8203000f},
{0x74,0xf6086441},
{0x78,0x80a6e000},
{0x7c,0x02800024},
{0xf0,0x53},
{0x00,0xf4086440},
{0x04,0xc208217d},
{0x08,0x80807fff},
{0x0c,0xf40ea37f},
{0x10,0xf60ee37f},
{0x14,0x0c80001a},
{0x18,0xb2102000},
{0x1c,0xb007bff8},
{0x20,0xc200247c},
{0x24,0x82584019},
{0x28,0xba06c001},
{0x2c,0x82068001},
{0x30,0x82004001},
{0x34,0xf8528001},
{0x38,0xba07401d},
{0x3c,0xc252801d},
{0x40,0xb8270001},
{0x44,0x80a66000},
{0x48,0x02800007},
{0x4c,0xf8263f98},
{0x50,0xc2063f94},
{0x54,0x82a70001},
{0x58,0x2c800003},
{0x5c,0x9a234001},
{0x60,0x9a034001},
{0x64,0xc208217d},
{0x68,0xb2066001},
{0x6c,0x82007fff},
{0x70,0x80a64001},
{0x74,0x04bfffeb},
{0x78,0xb0062004},
{0x7c,0x9e03e001},
{0xf0,0x54},
{0x00,0x80a3e00a},
{0x04,0x04bfffdc},
{0x08,0x8203000f},
{0x0c,0x9602e001},
{0x10,0x80a2e001},
{0x14,0x04bfffd6},
{0x18,0x9803200c},
{0x1c,0xda20259c},
{0x20,0x81c7e008},
{0x24,0x81e80000},
{0x28,0x9de3bf58},
{0x2c,0xc208224d},
{0x30,0x80a06000},
{0x34,0x12800004},
{0x38,0x94067ffe},
{0x3c,0xc020259c},
{0x40,0x30800065},
{0x44,0xa6066002},
{0x48,0x80a28013},
{0x4c,0x1480003f},
{0x50,0x90102000},
{0x54,0xa0062002},
{0x58,0x96063ffe},
{0x5c,0x80a2c010},
{0x60,0x14800036},
{0x64,0x833aa01f},
{0x68,0x8220400a},
{0x6c,0x9a064019},
{0x70,0x9a23400a},
{0x74,0x992a2002},
{0x78,0xab30601f},
{0x7c,0x9803001e},
{0xf0,0x55},
{0x00,0x03000018},
{0x04,0xa92b6004},
{0x08,0xac1060e0},
{0x0c,0x98033fb8},
{0x10,0xa4063fff},
{0x14,0xa2062001},
{0x18,0x9a067fff},
{0x1c,0x82060018},
{0x20,0x8220400b},
{0x24,0x82050001},
{0x28,0x80a2c012},
{0x2c,0x0680000b},
{0x30,0x9f286002},
{0x34,0x80a2c011},
{0x38,0x14800009},
{0x3c,0x80a2e000},
{0x40,0x80a2800d},
{0x44,0x06800005},
{0x48,0x82066001},
{0x4c,0x80a28001},
{0x50,0x24800017},
{0x54,0x9602e001},
{0x58,0x80a2e000},
{0x5c,0x24800010},
{0x60,0xc203c016},
{0x64,0xc2002308},
{0x68,0x80a0400b},
{0x6c,0x82603fff},
{0x70,0x80884015},
{0x74,0x2280000a},
{0x78,0xc203c016},
{0x7c,0x832aa004},
{0xf0,0x56},
{0x00,0x8200400b},
{0x04,0x93286002},
{0x08,0xc2002300},
{0x0c,0x80a28001},
{0x10,0x38800003},
{0x14,0xc203c016},
{0x18,0xc2024016},
{0x1c,0xc2230000},
{0x20,0x90022001},
{0x24,0x98032004},
{0x28,0x9602e001},
{0x2c,0x80a2c010},
{0x30,0x04bfffdc},
{0x34,0x82060018},
{0x38,0x9402a001},
{0x3c,0x80a28013},
{0x40,0x04bfffc7},
{0x44,0x96063ffe},
{0x48,0x9007bfb8},
{0x4c,0x7ffff8a2},
{0x50,0x92102010},
{0x54,0xd608224f},
{0x58,0xb00ae0ff},
{0x5c,0xd808224d},
{0x60,0x80a6000c},
{0x64,0x1480000b},
{0x68,0x90102000},
{0x6c,0x832e2002},
{0x70,0x8200401e},
{0x74,0x9a007fb8},
{0x78,0xc2034000},
{0x7c,0xb0062001},
{0xf0,0x57},
{0x00,0x90020001},
{0x04,0x80a6000c},
{0x08,0x04bffffc},
{0x0c,0x9a036004},
{0x10,0x820ae0ff},
{0x14,0xda08224d},
{0x18,0x9a234001},
{0x1c,0xc208224c},
{0x20,0x9a036001},
{0x24,0x825a0001},
{0x28,0x9938601f},
{0x2c,0x81832000},
{0x30,0x01000000},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0x8278400d},
{0x40,0x9b38601f},
{0x44,0x9b336019},
{0x48,0x8200400d},
{0x4c,0x83386007},
{0x50,0xc220259c},
{0x54,0x81c7e008},
{0x58,0x81e80000},
{0x5c,0x9de3bf98},
{0x60,0xc2002540},
{0x64,0x82006001},
{0x68,0xc2202540},
{0x6c,0xc2002588},
{0x70,0x80a06000},
{0x74,0x02800014},
{0x78,0x11000017},
{0x7c,0xc2002594},
{0xf0,0x58},
{0x00,0x80a06000},
{0x04,0x12800004},
{0x08,0x90122208},
{0x0c,0x7ffffbff},
{0x10,0x01000000},
{0x14,0xda002588},
{0x18,0xc2002594},
{0x1c,0x82006001},
{0x20,0x9a037fff},
{0x24,0xc2202594},
{0x28,0x7ffff9ab},
{0x2c,0xda202588},
{0x30,0x13000017},
{0x34,0x92126208},
{0x38,0xc2002fc0},
{0x3c,0x9fc04000},
{0x40,0xd4002594},
{0x44,0x01000000},
{0x48,0x81c7e008},
{0x4c,0x81e80000},
{0x50,0xc2002588},
{0x54,0x80a06001},
{0x58,0x1280001a},
{0x5c,0xda002298},
{0x60,0xc2102548},
{0x64,0x80886001},
{0x68,0x22800009},
{0x6c,0xc2002208},
{0x70,0xc2002170},
{0x74,0x80a06000},
{0x78,0x22800005},
{0x7c,0xc2002208},
{0xf0,0x59},
{0x00,0xc0202598},
{0x04,0x1080000f},
{0x08,0x9a100001},
{0x0c,0x80a06000},
{0x10,0x22800009},
{0x14,0xc2002598},
{0x18,0xc2002558},
{0x1c,0x80a06000},
{0x20,0x32800005},
{0x24,0xc2002598},
{0x28,0xc0202598},
{0x2c,0x10800005},
{0x30,0xda002234},
{0x34,0x80a06000},
{0x38,0x22800002},
{0x3c,0xda00233c},
{0x40,0x033fc200},
{0x44,0x82106070},
{0x48,0x81c3e008},
{0x4c,0xda204000},
{0x50,0x9de3bf98},
{0x54,0xc2002588},
{0x58,0x80a06000},
{0x5c,0x02800010},
{0x60,0x11000017},
{0x64,0xd8002548},
{0x68,0x83332010},
{0x6c,0x80886001},
{0x70,0x22800010},
{0x74,0xc200258c},
{0x78,0xc2002558},
{0x7c,0x80a06000},
{0xf0,0x5a},
{0x00,0x3280000c},
{0x04,0xc200258c},
{0x08,0xc2002594},
{0x0c,0x80a06001},
{0x10,0x32800008},
{0x14,0xc200258c},
{0x18,0x11000017},
{0x1c,0x90122208},
{0x20,0xd0202590},
{0x24,0xc0202588},
{0x28,0x1080001a},
{0x2c,0xd2002594},
{0x30,0x80a06000},
{0x34,0x12800015},
{0x38,0x82102001},
{0x3c,0xda002554},
{0x40,0xc2002598},
{0x44,0x80a0400d},
{0x48,0x1a800007},
{0x4c,0x03000014},
{0x50,0x82102001},
{0x54,0xda20258c},
{0x58,0xc2202584},
{0x5c,0x1080002b},
{0x60,0xc0202598},
{0x64,0x808b2400},
{0x68,0x12800004},
{0x6c,0x821062a8},
{0x70,0x03000013},
{0x74,0x821063d0},
{0x78,0xc2202590},
{0x7c,0xd2002598},
{0xf0,0x5b},
{0x00,0x10800004},
{0x04,0xd0002590},
{0x08,0x10800020},
{0x0c,0xc2202584},
{0x10,0x7ffffba6},
{0x14,0x01000000},
{0x18,0x13000016},
{0x1c,0xc2002fd0},
{0x20,0x92126330},
{0x24,0x9fc04000},
{0x28,0xd0002590},
{0x2c,0xc2002690},
{0x30,0x82087dff},
{0x34,0xc2202690},
{0x38,0x82102080},
{0x3c,0xc220256c},
{0x40,0xc2002200},
{0x44,0x80a06000},
{0x48,0x32800008},
{0x4c,0xc2002548},
{0x50,0xda002548},
{0x54,0x83336010},
{0x58,0x80886001},
{0x5c,0x22800006},
{0x60,0x03000004},
{0x64,0xc2002548},
{0x68,0x1b000004},
{0x6c,0x10800003},
{0x70,0x8210400d},
{0x74,0x822b4001},
{0x78,0xc2202548},
{0x7c,0xc2002548},
{0xf0,0x5c},
{0x00,0x82087fbf},
{0x04,0xc2202548},
{0x08,0x81c7e008},
{0x0c,0x81e80000},
{0x10,0xda002508},
{0x14,0x033fc000},
{0x18,0x960b4001},
{0x1c,0x808b7f00},
{0x20,0x0280001a},
{0x24,0x901020a5},
{0x28,0x1500003f},
{0x2c,0x8212a300},
{0x30,0x980b4001},
{0x34,0x03294000},
{0x38,0x80a2c001},
{0x3c,0x02800013},
{0x40,0x01000000},
{0x44,0xc200254c},
{0x48,0x8210400c},
{0x4c,0xc220254c},
{0x50,0xc2002500},
{0x54,0x80a06028},
{0x58,0xc0202508},
{0x5c,0x0880000b},
{0x60,0x033fffc0},
{0x64,0x9a0b4001},
{0x68,0x03168000},
{0x6c,0x80a2c001},
{0x70,0x12800006},
{0x74,0x9812a3ff},
{0x78,0xc2002548},
{0x7c,0x8208400c},
{0xf0,0x5d},
{0x00,0x8210400d},
{0x04,0xc2202548},
{0x08,0x03000006},
{0x0c,0x81c06384},
{0x10,0x01000000},
{0x14,0x01000000},
{0x18,0xda00247c},
{0x1c,0xc20022f8},
{0x20,0x8258400d},
{0x24,0x83306001},
{0x28,0x9a102000},
{0x2c,0x80a34001},
{0x30,0x1a800015},
{0x34,0x031fffdf},
{0x38,0x961063ff},
{0x3c,0x98036001},
{0x40,0x80a26008},
{0x44,0x04800006},
{0x48,0x9b2b6002},
{0x4c,0xc202000d},
{0x50,0x83306001},
{0x54,0x10800003},
{0x58,0x8208400b},
{0x5c,0xc202000d},
{0x60,0x82584009},
{0x64,0xc222000d},
{0x68,0xda00247c},
{0x6c,0xc20022f8},
{0x70,0x8258400d},
{0x74,0x83306001},
{0x78,0x80a30001},
{0x7c,0x0abffff0},
{0xf0,0x5e},
{0x00,0x9a10000c},
{0x04,0x81c3e008},
{0x08,0x01000000},
{0x0c,0x9de3bf98},
{0x10,0xc2102548},
{0x14,0x80886001},
{0x18,0x12800068},
{0x1c,0x01000000},
{0x20,0xe6002460},
{0x24,0x80a4e000},
{0x28,0x02800064},
{0x2c,0x01000000},
{0x30,0xc2002588},
{0x34,0xda002594},
{0x38,0x9800400d},
{0x3c,0xc2002554},
{0x40,0x80a30001},
{0x44,0x1280005d},
{0x48,0x01000000},
{0x4c,0xda002598},
{0x50,0xc200258c},
{0x54,0x8200400d},
{0x58,0x80a0400c},
{0x5c,0x02800004},
{0x60,0x80a36000},
{0x64,0x12800055},
{0x68,0x01000000},
{0x6c,0x96102001},
{0x70,0xc208217e},
{0x74,0x80a2c001},
{0x78,0x1480002e},
{0x7c,0x9e102000},
{0xf0,0x5f},
{0x00,0xa4100001},
{0x04,0xe208217f},
{0x08,0x13000018},
{0x0c,0x94102001},
{0x10,0x80a28011},
{0x14,0x14800020},
{0x18,0xa0102000},
{0x1c,0x832ae002},
{0x20,0x98006040},
{0x24,0xac1260e0},
{0x28,0xaa1260a0},
{0x2c,0xa8126120},
{0x30,0xd008217f},
{0x34,0xda030016},
{0x38,0x80a34013},
{0x3c,0x26800013},
{0x40,0x9402a001},
{0x44,0x80a2a001},
{0x48,0x22800007},
{0x4c,0xc208217f},
{0x50,0xc2030015},
{0x54,0x80a34001},
{0x58,0x2480000c},
{0x5c,0x9402a001},
{0x60,0xc208217f},
{0x64,0x80a28001},
{0x68,0x22800007},
{0x6c,0xa0042001},
{0x70,0xc2030014},
{0x74,0x80a34001},
{0x78,0x26800004},
{0x7c,0x9402a001},
{0xf0,0x60},
{0x00,0xa0042001},
{0x04,0x9402a001},
{0x08,0x80a28008},
{0x0c,0x04bfffea},
{0x10,0x98032040},
{0x14,0x80a4000f},
{0x18,0x34800002},
{0x1c,0x9e100010},
{0x20,0x9602e001},
{0x24,0x80a2c012},
{0x28,0x24bfffda},
{0x2c,0x94102001},
{0x30,0x96102000},
{0x34,0xc20ae464},
{0x38,0x80a06000},
{0x3c,0x22800006},
{0x40,0x9602e001},
{0x44,0x80a3c001},
{0x48,0x34800007},
{0x4c,0xc20ae278},
{0x50,0x9602e001},
{0x54,0x80a2e003},
{0x58,0x24bffff8},
{0x5c,0xc20ae464},
{0x60,0x30800016},
{0x64,0xda00256c},
{0x68,0x8258400d},
{0x6c,0x83306007},
{0x70,0xc220256c},
{0x74,0xe00ae468},
{0x78,0x80a42000},
{0x7c,0x0280000f},
{0xf0,0x61},
{0x00,0x82102001},
{0x04,0xc2202584},
{0x08,0xd0002590},
{0x0c,0x7fffff83},
{0x10,0xd2002554},
{0x14,0xc2002588},
{0x18,0x82004010},
{0x1c,0xc2202588},
{0x20,0xda00258c},
{0x24,0xc2002554},
{0x28,0x80a34001},
{0x2c,0x18800003},
{0x30,0x82034010},
{0x34,0xc220258c},
{0x38,0x81c7e008},
{0x3c,0x81e80000},
{0x40,0x9de3bf98},
{0x44,0xc2002588},
{0x48,0x80a06000},
{0x4c,0x12800060},
{0x50,0x01000000},
{0x54,0xc20026f4},
{0x58,0x82006001},
{0x5c,0xda002310},
{0x60,0x80a0400d},
{0x64,0x0a80005a},
{0x68,0xc22026f4},
{0x6c,0xd800227c},
{0x70,0x80a32000},
{0x74,0x02800032},
{0x78,0xc02026f4},
{0x7c,0xda0022f8},
{0xf0,0x62},
{0x00,0xc200247c},
{0x04,0x965b4001},
{0x08,0x03000007},
{0x0c,0x821063ff},
{0x10,0x9b33200d},
{0x14,0xa2102000},
{0x18,0x920b4001},
{0x1c,0x80a4400b},
{0x20,0x900b0001},
{0x24,0x94102000},
{0x28,0x1a800015},
{0x2c,0xa0102000},
{0x30,0x03000017},
{0x34,0xa4106208},
{0x38,0x82007c00},
{0x3c,0x9e106330},
{0x40,0x9a040010},
{0x44,0xc2134012},
{0x48,0x80a24001},
{0x4c,0xa2400011},
{0x50,0xc253400f},
{0x54,0x80a04008},
{0x58,0x0a800005},
{0x5c,0xa0042001},
{0x60,0x80a04009},
{0x64,0x08800004},
{0x68,0x80a4000b},
{0x6c,0x9402a001},
{0x70,0x80a4000b},
{0x74,0x0abffff4},
{0x78,0x9a040010},
{0x7c,0xa133201a},
{0xf0,0x63},
{0x00,0x80a44010},
{0x04,0x14800003},
{0x08,0x9a102001},
{0x0c,0x9a102000},
{0x10,0x80a28010},
{0x14,0x14800003},
{0x18,0x82102001},
{0x1c,0x82102000},
{0x20,0x80934001},
{0x24,0x22800007},
{0x28,0xc2002274},
{0x2c,0x033fc180},
{0x30,0x1b008000},
{0x34,0x8210603c},
{0x38,0xda204000},
{0x3c,0xc2002274},
{0x40,0x80a06000},
{0x44,0x02800022},
{0x48,0xa2102000},
{0x4c,0xc20023d4},
{0x50,0x80a44001},
{0x54,0xa4102000},
{0x58,0x1a800016},
{0x5c,0xa0102000},
{0x60,0xc200247c},
{0x64,0x80a40001},
{0x68,0x3a80000f},
{0x6c,0xa404a001},
{0x70,0x7ffff8c3},
{0x74,0x90100010},
{0x78,0x92100008},
{0x7c,0x7ffff852},
{0xf0,0x64},
{0x00,0x90100012},
{0x04,0x0300003f},
{0x08,0xda002274},
{0x0c,0x821063ff},
{0x10,0x9a0b4001},
{0x14,0x80a2000d},
{0x18,0xa2400011},
{0x1c,0x10bffff1},
{0x20,0xa0042001},
{0x24,0xc20023d4},
{0x28,0x10bfffec},
{0x2c,0x80a48001},
{0x30,0xc2102274},
{0x34,0x80a44001},
{0x38,0x08800005},
{0x3c,0x033fc180},
{0x40,0x1b004000},
{0x44,0x8210603c},
{0x48,0xda204000},
{0x4c,0x81c7e008},
{0x50,0x81e80000},
{0x54,0x9de3bf98},
{0x58,0xc2002fbc},
{0x5c,0x9fc04000},
{0x60,0x01000000},
{0x64,0x01000000},
{0x68,0x81c7e008},
{0x6c,0x81e80000},
{0x70,0x9de3bf30},
{0x74,0xe2502458},
{0x78,0x80a46000},
{0x7c,0x02800065},
{0xf0,0x65},
{0x00,0x01000000},
{0x04,0xc208217f},
{0x08,0x80a44001},
{0x0c,0x16800061},
{0x10,0xa0102001},
{0x14,0xc208217e},
{0x18,0x80a40001},
{0x1c,0x1480005d},
{0x20,0xe450245a},
{0x24,0x96102001},
{0x28,0xc208217f},
{0x2c,0x80a2c001},
{0x30,0x1480000f},
{0x34,0x03000018},
{0x38,0x9b2c2002},
{0x3c,0x821060e0},
{0x40,0x9a034001},
{0x44,0x9a036040},
{0x48,0x9807bf90},
{0x4c,0xc2034000},
{0x50,0xc2230000},
{0x54,0x9602e001},
{0x58,0xc208217f},
{0x5c,0x80a2c001},
{0x60,0x9a036040},
{0x64,0x04bffffa},
{0x68,0x98032004},
{0x6c,0x9007bf90},
{0x70,0x7ffff6b9},
{0x74,0xd208217f},
{0x78,0x96100012},
{0x7c,0x80a48011},
{0xf0,0x66},
{0x00,0x1480000b},
{0x04,0x94102000},
{0x08,0x832ca002},
{0x0c,0x8200401e},
{0x10,0x9a007f90},
{0x14,0xc2034000},
{0x18,0x9602e001},
{0x1c,0x94028001},
{0x20,0x80a2c011},
{0x24,0x04bffffc},
{0x28,0x9a036004},
{0x2c,0x82244012},
{0x30,0x82006001},
{0x34,0x9b3aa01f},
{0x38,0x81836000},
{0x3c,0x01000000},
{0x40,0x01000000},
{0x44,0x01000000},
{0x48,0x947a8001},
{0x4c,0xc25021ac},
{0x50,0x80a28001},
{0x54,0x26800002},
{0x58,0x94100001},
{0x5c,0x96102001},
{0x60,0xc208217f},
{0x64,0x80a2c001},
{0x68,0x14800025},
{0x6c,0x832c2002},
{0x70,0x11000018},
{0x74,0x98006040},
{0x78,0x921220e0},
{0x7c,0x80a2a000},
{0xf0,0x67},
{0x00,0x0480000b},
{0x04,0x9a1220e0},
{0x08,0xc203000d},
{0x0c,0x80a0400a},
{0x10,0x36800008},
{0x14,0xc2030009},
{0x18,0x80a06000},
{0x1c,0x34800007},
{0x20,0xc023000d},
{0x24,0x10800006},
{0x28,0xc20023c8},
{0x2c,0xc2030009},
{0x30,0x8220400a},
{0x34,0xc2230009},
{0x38,0xc20023c8},
{0x3c,0x83306012},
{0x40,0x80886001},
{0x44,0x0280000a},
{0x48,0x9602e001},
{0x4c,0xda0c22af},
{0x50,0xc2030009},
{0x54,0x8258400d},
{0x58,0x9b38601f},
{0x5c,0x9b336019},
{0x60,0x8200400d},
{0x64,0x83386007},
{0x68,0xc2230009},
{0x6c,0xc208217f},
{0x70,0x80a2c001},
{0x74,0x04bfffe2},
{0x78,0x98032040},
{0x7c,0xa0042001},
{0xf0,0x68},
{0x00,0xc208217e},
{0x04,0x80a40001},
{0x08,0x04bfffa8},
{0x0c,0x96102001},
{0x10,0x81c7e008},
{0x14,0x81e80000},
{0x18,0x9de3bf98},
{0x1c,0xc25023c6},
{0x20,0x80a06000},
{0x24,0x02800049},
{0x28,0xb0102001},
{0x2c,0xc208217e},
{0x30,0x80a60001},
{0x34,0x14800045},
{0x38,0x1b000018},
{0x3c,0x821360e0},
{0x40,0x9e006004},
{0x44,0xc208217f},
{0x48,0x80a06000},
{0x4c,0xba102000},
{0x50,0x02800039},
{0x54,0xb4102000},
{0x58,0xb8100001},
{0x5c,0xf25023c4},
{0x60,0x8203e040},
{0x64,0xf6004000},
{0x68,0x80a6c019},
{0x6c,0x06800004},
{0x70,0x82006040},
{0x74,0xba07401b},
{0x78,0xb406a001},
{0x7c,0xb8873fff},
{0xf0,0x69},
{0x00,0x32bffffa},
{0x04,0xf6004000},
{0x08,0x80a6a000},
{0x0c,0x2280002b},
{0x10,0xb0062001},
{0x14,0xc21023c4},
{0x18,0x80886001},
{0x1c,0xc21023c6},
{0x20,0x0280000a},
{0x24,0xf808217f},
{0x28,0x83286010},
{0x2c,0x83386010},
{0x30,0x825f4001},
{0x34,0xbb38601f},
{0x38,0xbb376016},
{0x3c,0x8200401d},
{0x40,0x1080000f},
{0x44,0xbb38600a},
{0x48,0x83286010},
{0x4c,0x83386010},
{0x50,0x993f601f},
{0x54,0x81832000},
{0x58,0x01000000},
{0x5c,0x01000000},
{0x60,0x01000000},
{0x64,0xba7f401a},
{0x68,0xba5f4001},
{0x6c,0x833f601f},
{0x70,0x83306016},
{0x74,0xba074001},
{0x78,0xbb3f600a},
{0x7c,0x80a72000},
{0xf0,0x6a},
{0x00,0x0280000d},
{0x04,0xb8102001},
{0x08,0x832e2002},
{0x0c,0xb6006040},
{0x10,0xb41360e0},
{0x14,0xc206c01a},
{0x18,0x8220401d},
{0x1c,0xc226c01a},
{0x20,0xb8072001},
{0x24,0xc208217f},
{0x28,0x80a70001},
{0x2c,0x04bffffa},
{0x30,0xb606e040},
{0x34,0xb0062001},
{0x38,0xc208217e},
{0x3c,0x80a60001},
{0x40,0x04bfffc1},
{0x44,0x9e03e004},
{0x48,0x81c7e008},
{0x4c,0x81e80000},
{0x50,0xc2082573},
{0x54,0xda00256c},
{0x58,0x82006001},
{0x5c,0xd808257f},
{0x60,0x9a5b4001},
{0x64,0x98032001},
{0x68,0x81800000},
{0x6c,0x01000000},
{0x70,0x01000000},
{0x74,0x01000000},
{0x78,0x9a73400c},
{0x7c,0xda20256c},
{0xf0,0x6b},
{0x00,0x96102000},
{0x04,0x832ae002},
{0x08,0xd800256c},
{0x0c,0xda1063b6},
{0x10,0x9a5b400c},
{0x14,0x9b336007},
{0x18,0x9602e001},
{0x1c,0x80a2e003},
{0x20,0x04bffff9},
{0x24,0xda206520},
{0x28,0xc20023c0},
{0x2c,0x80a06000},
{0x30,0x02800007},
{0x34,0x82103000},
{0x38,0xc2002200},
{0x3c,0x80a06000},
{0x40,0x22800005},
{0x44,0xc200255c},
{0x48,0x82103000},
{0x4c,0xc220252c},
{0x50,0xc200255c},
{0x54,0x80a06000},
{0x58,0x02800005},
{0x5c,0xc2002288},
{0x60,0x9b306001},
{0x64,0x83306002},
{0x68,0x8200400d},
{0x6c,0xc220251c},
{0x70,0x03000007},
{0x74,0x81c06298},
{0x78,0x01000000},
{0x7c,0x01000000},
{0xf0,0x6c},
{0x00,0x9de3bf98},
{0x04,0xc2002548},
{0x08,0x80886100},
{0x0c,0xaa102000},
{0x10,0x128000cb},
{0x14,0xa6102000},
{0x18,0xc20026e4},
{0x1c,0x80a06000},
{0x20,0x02800004},
{0x24,0xa2102001},
{0x28,0x82007fff},
{0x2c,0xc22026e4},
{0x30,0xc2002300},
{0x34,0x80a44001},
{0x38,0x388000a5},
{0x3c,0xda002530},
{0x40,0xa4102001},
{0x44,0xc2002308},
{0x48,0x80a48001},
{0x4c,0x1880008f},
{0x50,0x03000050},
{0x54,0xa8044001},
{0x58,0xc2002514},
{0x5c,0x80a06009},
{0x60,0x1880009a},
{0x64,0x9b2c6004},
{0x68,0x9a034012},
{0x6c,0x03000018},
{0x70,0x821060e0},
{0x74,0x9b2b6002},
{0x78,0xda034001},
{0x7c,0xc2002474},
{0xf0,0x6d},
{0x00,0x80a34001},
{0x04,0x0680007b},
{0x08,0x03000040},
{0x0c,0x90100012},
{0x10,0x7ffff9c2},
{0x14,0x92100011},
{0x18,0x80a22000},
{0x1c,0x02800075},
{0x20,0x03000040},
{0x24,0xc2002ff0},
{0x28,0x80a06000},
{0x2c,0x2280000a},
{0x30,0xc2002fe0},
{0x34,0x90100012},
{0x38,0x9fc04000},
{0x3c,0x92100011},
{0x40,0xc200259c},
{0x44,0x80a06000},
{0x48,0x1280006a},
{0x4c,0x03000040},
{0x50,0xc2002fe0},
{0x54,0x80a06000},
{0x58,0x2280000b},
{0x5c,0xc2002ff4},
{0x60,0x90100012},
{0x64,0x92100011},
{0x68,0x9fc04000},
{0x6c,0xd4082473},
{0x70,0xc200259c},
{0x74,0x80a06000},
{0x78,0x1280005e},
{0x7c,0x03000040},
{0xf0,0x6e},
{0x00,0xc2002ff4},
{0x04,0x80a06000},
{0x08,0x02800006},
{0x0c,0xa0102000},
{0x10,0x90100012},
{0x14,0x9fc04000},
{0x18,0x92100011},
{0x1c,0xe000259c},
{0x20,0x90100012},
{0x24,0x92100011},
{0x28,0x94100010},
{0x2c,0x7ffff9e6},
{0x30,0xd6082473},
{0x34,0x80a22000},
{0x38,0x0280004e},
{0x3c,0x03000040},
{0x40,0xc2002fe0},
{0x44,0x80a06000},
{0x48,0x02800007},
{0x4c,0x90100012},
{0x50,0x92100011},
{0x54,0x9fc04000},
{0x58,0x94102100},
{0x5c,0x10800004},
{0x60,0x94100010},
{0x64,0xc020259c},
{0x68,0x94100010},
{0x6c,0x90100012},
{0x70,0x92100011},
{0x74,0x7ffff9d4},
{0x78,0x96102100},
{0x7c,0x80a22000},
{0xf0,0x6f},
{0x00,0x22800011},
{0x04,0xc2002514},
{0x08,0xc200259c},
{0x0c,0x80a06000},
{0x10,0x3280000d},
{0x14,0xc2002514},
{0x18,0xc2002280},
{0x1c,0xd8002514},
{0x20,0xc22026e4},
{0x24,0x9b2ca010},
{0x28,0x832b2002},
{0x2c,0x9a034011},
{0x30,0xda206710},
{0x34,0x98032001},
{0x38,0xd8202514},
{0x3c,0x10800006},
{0x40,0xaa056001},
{0x44,0x9b286002},
{0x48,0xe8236710},
{0x4c,0x82006001},
{0x50,0xc2202514},
{0x54,0xc2002514},
{0x58,0x80a0600a},
{0x5c,0x12800025},
{0x60,0x03000040},
{0x64,0x03000018},
{0x68,0x9e1060e0},
{0x6c,0xe6002710},
{0x70,0x90102001},
{0x74,0x932a2002},
{0x78,0xd4026710},
{0x7c,0x820aafff},
{0xf0,0x70},
{0x00,0x9932a010},
{0x04,0x980b2fff},
{0x08,0x9a0cefff},
{0x0c,0x9734e010},
{0x10,0x83286004},
{0x14,0x8200400c},
{0x18,0x960aefff},
{0x1c,0x9b2b6004},
{0x20,0x83286002},
{0x24,0x9a03400b},
{0x28,0xd800400f},
{0x2c,0x9b2b6002},
{0x30,0xc203400f},
{0x34,0x80a30001},
{0x38,0x36800004},
{0x3c,0xd422670c},
{0x40,0xe622670c},
{0x44,0xa610000a},
{0x48,0x90022001},
{0x4c,0xc2002514},
{0x50,0x80a20001},
{0x54,0x2abfffe9},
{0x58,0x932a2002},
{0x5c,0x82007fff},
{0x60,0xc2202514},
{0x64,0x83286002},
{0x68,0xc0206710},
{0x6c,0x03000040},
{0x70,0xa8050001},
{0x74,0xa404a001},
{0x78,0xc2002308},
{0x7c,0x80a48001},
{0xf0,0x71},
{0x00,0x28bfff77},
{0x04,0xc2002514},
{0x08,0xa2046001},
{0x0c,0xc2002300},
{0x10,0x80a44001},
{0x14,0x28bfff6c},
{0x18,0xa4102001},
{0x1c,0x80a4e000},
{0x20,0x2280000b},
{0x24,0xda002530},
{0x28,0xda002514},
{0x2c,0x80a36009},
{0x30,0x38800007},
{0x34,0xda002530},
{0x38,0x832b6002},
{0x3c,0xe6206710},
{0x40,0x82036001},
{0x44,0xc2202514},
{0x48,0xda002530},
{0x4c,0x80a5400d},
{0x50,0x14800006},
{0x54,0x82100015},
{0x58,0xc2002514},
{0x5c,0x80a34001},
{0x60,0x28800002},
{0x64,0x8210000d},
{0x68,0x80a56000},
{0x6c,0x02800004},
{0x70,0xc2202530},
{0x74,0x1080000a},
{0x78,0xc20021f8},
{0x7c,0x80a06000},
{0xf0,0x72},
{0x00,0x22800009},
{0x04,0xc2002530},
{0x08,0xc20026f8},
{0x0c,0x80a06000},
{0x10,0x22800004},
{0x14,0xc0202530},
{0x18,0x82006001},
{0x1c,0xc22026f8},
{0x20,0xc2002530},
{0x24,0x80a06000},
{0x28,0x02800005},
{0x2c,0x01000000},
{0x30,0xc2002548},
{0x34,0x82106040},
{0x38,0xc2202548},
{0x3c,0x81c7e008},
{0x40,0x81e80000},
{0x44,0x82220009},
{0x48,0x9a58400a},
{0x4c,0x833b601f},
{0x50,0x80a20009},
{0x54,0x83306019},
{0x58,0x04800004},
{0x5c,0x90102000},
{0x60,0x82034001},
{0x64,0x91386007},
{0x68,0x81c3e008},
{0x6c,0x01000000},
{0x70,0x9de3bf98},
{0x74,0x7ffff9da},
{0x78,0xa6102001},
{0x7c,0xc208217f},
{0xf0,0x73},
{0x00,0x80a07fff},
{0x04,0x2280001d},
{0x08,0xa6102001},
{0x0c,0x23000018},
{0x10,0xa12ce006},
{0x14,0x821460e8},
{0x18,0xa41460e4},
{0x1c,0xd2040001},
{0x20,0xd408228c},
{0x24,0x7fffffe8},
{0x28,0xd0040012},
{0x2c,0x9a1460e0},
{0x30,0xd024000d},
{0x34,0xc2002308},
{0x38,0xa12ce004},
{0x3c,0xa0040001},
{0x40,0xa12c2002},
{0x44,0xa21460dc},
{0x48,0xd004000d},
{0x4c,0xd2040011},
{0x50,0x7fffffdd},
{0x54,0xd408228d},
{0x58,0xd0240012},
{0x5c,0xc208217f},
{0x60,0xa604e001},
{0x64,0x82006001},
{0x68,0x80a4c001},
{0x6c,0x08bfffe9},
{0x70,0x23000018},
{0x74,0xa6102001},
{0x78,0xc2002308},
{0x7c,0x80a4c001},
{0xf0,0x74},
{0x00,0x1880001a},
{0x04,0x23000018},
{0x08,0xa12ce002},
{0x0c,0x82146160},
{0x10,0xa4146120},
{0x14,0xd2040001},
{0x18,0xd408228e},
{0x1c,0x7fffffca},
{0x20,0xd0040012},
{0x24,0x821460e0},
{0x28,0xd0240001},
{0x2c,0xe0002300},
{0x30,0xa12c2004},
{0x34,0xa0040013},
{0x38,0xa12c2002},
{0x3c,0xa21460a0},
{0x40,0xd0040001},
{0x44,0xd2040011},
{0x48,0x7fffffbf},
{0x4c,0xd408228f},
{0x50,0xd0240012},
{0x54,0xa604e001},
{0x58,0xc2002308},
{0x5c,0x80a4c001},
{0x60,0x08bfffea},
{0x64,0x23000018},
{0x68,0x81c7e008},
{0x6c,0x81e80000},
{0x70,0x9de3bf88},
{0x74,0xc2002fe4},
{0x78,0x9fc04000},
{0x7c,0xd0002590},
{0xf0,0x75},
{0x00,0xda002550},
{0x04,0x832b6004},
{0x08,0x8220400d},
{0x0c,0xe000259c},
{0x10,0x82040001},
{0x14,0x83306004},
{0x18,0xc2202550},
{0x1c,0x11000016},
{0x20,0xc2002fe4},
{0x24,0x9fc04000},
{0x28,0x90122330},
{0x2c,0xc208217c},
{0x30,0xda08217d},
{0x34,0x9a5b4001},
{0x38,0xc200259c},
{0x3c,0x8200400d},
{0x40,0xc220259c},
{0x44,0xda00259c},
{0x48,0xc2002550},
{0x4c,0x80a34001},
{0x50,0x28800011},
{0x54,0xc2002548},
{0x58,0xc200259c},
{0x5c,0x80a04010},
{0x60,0x0880000d},
{0x64,0xc2002548},
{0x68,0x80a42000},
{0x6c,0x0280000a},
{0x70,0x01000000},
{0x74,0x82087f7f},
{0x78,0xc2202548},
{0x7c,0xc2002658},
{0xf0,0x76},
{0x00,0x80a06000},
{0x04,0x26800006},
{0x08,0xc0202658},
{0x0c,0x10800005},
{0x10,0xc208254e},
{0x14,0x82106080},
{0x18,0xc2202548},
{0x1c,0xc208254e},
{0x20,0x80a00001},
{0x24,0x82602000},
{0x28,0xa0087ffe},
{0x2c,0xd8002548},
{0x30,0x83332010},
{0x34,0x80886001},
{0x38,0x02800012},
{0x3c,0xa0042003},
{0x40,0x03000180},
{0x44,0x820b0001},
{0x48,0x1b000080},
{0x4c,0x80a0400d},
{0x50,0x22800064},
{0x54,0xc02026d4},
{0x58,0xc2002160},
{0x5c,0x80886040},
{0x60,0x0280002f},
{0x64,0xa0102000},
{0x68,0xc2002558},
{0x6c,0x80a06000},
{0x70,0x0280002b},
{0x74,0xa0102002},
{0x78,0x10800029},
{0x7c,0xa0102000},
{0xf0,0x77},
{0x00,0x033fc200},
{0x04,0x82106030},
{0x08,0xda004000},
{0x0c,0xc2002570},
{0x10,0x80a34001},
{0x14,0x32800053},
{0x18,0xc02026d4},
{0x1c,0xc2002200},
{0x20,0x80a06000},
{0x24,0x3280004f},
{0x28,0xc02026d4},
{0x2c,0xda002690},
{0x30,0x03000007},
{0x34,0x808b4001},
{0x38,0x3280004a},
{0x3c,0xc02026d4},
{0x40,0x808b2001},
{0x44,0x32800047},
{0x48,0xc02026d4},
{0x4c,0xda002654},
{0x50,0xc20021dc},
{0x54,0x80a34001},
{0x58,0x2a800008},
{0x5c,0xc2002514},
{0x60,0xc200254c},
{0x64,0x8330600e},
{0x68,0x80886001},
{0x6c,0x1280000a},
{0x70,0x808b2040},
{0x74,0xc2002514},
{0x78,0x80a06000},
{0x7c,0x22800009},
{0xf0,0x78},
{0x00,0xc20c2314},
{0x04,0x808b2080},
{0x08,0x22800006},
{0x0c,0xc20c2314},
{0x10,0x808b2040},
{0x14,0x32800033},
{0x18,0xc02026d4},
{0x1c,0xc20c2314},
{0x20,0x80a06000},
{0x24,0x2280002f},
{0x28,0xc02026d4},
{0x2c,0xc20026d4},
{0x30,0x98006001},
{0x34,0xc2002700},
{0x38,0xda082169},
{0x3c,0xd82026d4},
{0x40,0x80a0400d},
{0x44,0x0480000a},
{0x48,0xc20c2314},
{0x4c,0x820860ff},
{0x50,0xda082168},
{0x54,0x8258400d},
{0x58,0x80a30001},
{0x5c,0x06800021},
{0x60,0x01000000},
{0x64,0x10800007},
{0x68,0xc02026d4},
{0x6c,0x820860ff},
{0x70,0x80a30001},
{0x74,0x0680001b},
{0x78,0x01000000},
{0x7c,0xc02026d4},
{0xf0,0x79},
{0x00,0xc20c234c},
{0x04,0xc227bfec},
{0x08,0xc20c230c},
{0x0c,0xc227bff0},
{0x10,0xa0102000},
{0x14,0xc208217c},
{0x18,0x80a40001},
{0x1c,0x1a800011},
{0x20,0x01000000},
{0x24,0xc20c2380},
{0x28,0xc227bfe8},
{0x2c,0xa2102000},
{0x30,0xc208217d},
{0x34,0x80a44001},
{0x38,0x3a800006},
{0x3c,0xa0042001},
{0x40,0x7ffff91b},
{0x44,0x9007bfe8},
{0x48,0x10bffffa},
{0x4c,0xa2046001},
{0x50,0xc208217c},
{0x54,0x80a40001},
{0x58,0x2abffff4},
{0x5c,0xc20c2380},
{0x60,0x81c7e008},
{0x64,0x81e80000},
{0x68,0xd2002208},
{0x6c,0x80a26000},
{0x70,0x0280001a},
{0x74,0x01000000},
{0x78,0xc2102548},
{0x7c,0x80886001},
{0xf0,0x7a},
{0x00,0x12800016},
{0x04,0x01000000},
{0x08,0xc2002514},
{0x0c,0x80a06000},
{0x10,0x12800007},
{0x14,0xc2002558},
{0x18,0x80a06000},
{0x1c,0x0280000f},
{0x20,0x9a007fff},
{0x24,0x1080000d},
{0x28,0xda202558},
{0x2c,0x15200040},
{0x30,0x1b3fc200},
{0x34,0x9812a001},
{0x38,0x80a06000},
{0x3c,0x12800006},
{0x40,0x96136070},
{0x44,0xd8234000},
{0x48,0xc2002298},
{0x4c,0xc222c000},
{0x50,0xd4234000},
{0x54,0xd2202558},
{0x58,0x81c3e008},
{0x5c,0x01000000},
{0x60,0x92102000},
{0x64,0xc2002514},
{0x68,0x80a24001},
{0x6c,0x1a800019},
{0x70,0x912a6002},
{0x74,0xd4022710},
{0x78,0x820aafff},
{0x7c,0x9732a010},
{0xf0,0x7b},
{0x00,0x98006001},
{0x04,0x960aefff},
{0x08,0x82007fff},
{0x0c,0x83286018},
{0x10,0x992b2010},
{0x14,0x9a02ffff},
{0x18,0x8200400c},
{0x1c,0x9b2b6008},
{0x20,0x8200400d},
{0x24,0x8200400b},
{0x28,0x9532a00c},
{0x2c,0x92026001},
{0x30,0x808aa001},
{0x34,0x12800003},
{0x38,0x82006001},
{0x3c,0xc2222738},
{0x40,0xc2002514},
{0x44,0x80a24001},
{0x48,0x0abfffeb},
{0x4c,0x912a6002},
{0x50,0x81c3e008},
{0x54,0x01000000},
{0x58,0x9de3bf98},
{0x5c,0x94102000},
{0x60,0xc2002514},
{0x64,0x80a28001},
{0x68,0x1a80005d},
{0x6c,0x96102000},
{0x70,0xbb2aa002},
{0x74,0xf20f6738},
{0x78,0xc20f6739},
{0x7c,0x80a64001},
{0xf0,0x7c},
{0x00,0x98102000},
{0x04,0x9e102000},
{0x08,0x14800020},
{0x0c,0x9a102000},
{0x10,0x03000018},
{0x14,0x921060e0},
{0x18,0xc20f673b},
{0x1c,0xf60f673a},
{0x20,0x80a6c001},
{0x24,0x14800013},
{0x28,0x832e6004},
{0x2c,0x8200401b},
{0x30,0x83286002},
{0x34,0x82004009},
{0x38,0xf80ae73b},
{0x3c,0xfa004000},
{0x40,0xb05f401b},
{0x44,0x82006004},
{0x48,0xb606e001},
{0x4c,0x80a76000},
{0x50,0x04800005},
{0x54,0xb45f4019},
{0x58,0x9e03c01a},
{0x5c,0x9a034018},
{0x60,0x9803001d},
{0x64,0x80a6c01c},
{0x68,0x24bffff6},
{0x6c,0xfa004000},
{0x70,0xbb2aa002},
{0x74,0xb2066001},
{0x78,0xc20f6739},
{0x7c,0x80a64001},
{0xf0,0x7d},
{0x00,0x24bfffe7},
{0x04,0xc20f673b},
{0x08,0xbb2b6006},
{0x0c,0xb92be006},
{0x10,0xc202e710},
{0x14,0x9b3f201f},
{0x18,0x81836000},
{0x1c,0x01000000},
{0x20,0x01000000},
{0x24,0x01000000},
{0x28,0xb87f000c},
{0x2c,0x9b3f601f},
{0x30,0x81836000},
{0x34,0x01000000},
{0x38,0x01000000},
{0x3c,0x01000000},
{0x40,0xba7f400c},
{0x44,0x8330600c},
{0x48,0x80886001},
{0x4c,0x9e073fe0},
{0x50,0x02800007},
{0x54,0x9a077fe0},
{0x58,0xc200237c},
{0x5c,0x80a06000},
{0x60,0x22800003},
{0x64,0x9e073fa0},
{0x68,0x9a077fa0},
{0x6c,0x80a3e000},
{0x70,0x24800002},
{0x74,0x9e102001},
{0x78,0x80a36000},
{0x7c,0x24800002},
{0xf0,0x7e},
{0x00,0x9a102001},
{0x04,0xc208217f},
{0x08,0x83286006},
{0x0c,0x80a3c001},
{0x10,0x36800002},
{0x14,0x9e007fff},
{0x18,0xc208217e},
{0x1c,0x83286006},
{0x20,0x80a34001},
{0x24,0x36800002},
{0x28,0x9a007fff},
{0x2c,0xfa02e710},
{0x30,0x832be010},
{0x34,0x393c003c},
{0x38,0x8200400d},
{0x3c,0xba0f401c},
{0x40,0x8200401d},
{0x44,0xc222e710},
{0x48,0x9402a001},
{0x4c,0xc2002514},
{0x50,0x80a28001},
{0x54,0x0abfffa7},
{0x58,0x9602e004},
{0x5c,0x7ffff70a},
{0x60,0x91e8205a},
{0x64,0x01000000},
{0x68,0x9de3bf98},
{0x6c,0xd8002548},
{0x70,0x8333200c},
{0x74,0x80886001},
{0x78,0x12800081},
{0x7c,0x01000000},
{0xf0,0x7f},
{0x00,0xc208254d},
{0x04,0x80a06000},
{0x08,0x1280007d},
{0x0c,0x01000000},
{0x10,0xc208254e},
{0x14,0x80a06000},
{0x18,0x02800079},
{0x1c,0x01000000},
{0x20,0xc2002554},
{0x24,0x825860fa},
{0x28,0xda002500},
{0x2c,0x80a34001},
{0x30,0x0a800073},
{0x34,0x01000000},
{0x38,0xd6002658},
{0x3c,0x80a2e000},
{0x40,0x1480001c},
{0x44,0x8202ffff},
{0x48,0xc2002514},
{0x4c,0x80a06001},
{0x50,0x3280006b},
{0x54,0xc0202658},
{0x58,0xc2002710},
{0x5c,0x80a06000},
{0x60,0x12800004},
{0x64,0x808b2040},
{0x68,0x10800065},
{0x6c,0xc0202658},
{0x70,0x32800006},
{0x74,0xd800239c},
{0x78,0x80a2e000},
{0x7c,0x0680000d},
{0xf0,0x80},
{0x00,0x8202e001},
{0x04,0xd800239c},
{0x08,0x0300003f},
{0x0c,0x9b332010},
{0x10,0x821063ff},
{0x14,0x980b0001},
{0x18,0x9a38000d},
{0x1c,0x9a23400c},
{0x20,0x80a2c00d},
{0x24,0x06800005},
{0x28,0x03296956},
{0x2c,0x8202ffff},
{0x30,0x10800053},
{0x34,0xc2202658},
{0x38,0x9a10625a},
{0x3c,0xc200250c},
{0x40,0x80a0400d},
{0x44,0x02800004},
{0x48,0xa0102000},
{0x4c,0xda20250c},
{0x50,0xc0202654},
{0x54,0x832c2002},
{0x58,0x92006610},
{0x5c,0xc2006610},
{0x60,0x90102710},
{0x64,0x80a06000},
{0x68,0x0280000d},
{0x6c,0xa0042001},
{0x70,0x7ffff73a},
{0x74,0x01000000},
{0x78,0xc2002300},
{0x7c,0xda002308},
{0xf0,0x81},
{0x00,0x82584001},
{0x04,0x9a5b400d},
{0x08,0x8200400d},
{0x0c,0x83286006},
{0x10,0x80a20001},
{0x14,0x0a80003a},
{0x18,0x01000000},
{0x1c,0x80a4200f},
{0x20,0x08bfffee},
{0x24,0x832c2002},
{0x28,0x030041eb},
{0x2c,0xc2202658},
{0x30,0xa010200f},
{0x34,0x9b2c2002},
{0x38,0xc203660c},
{0x3c,0xa0843fff},
{0x40,0x12bffffd},
{0x44,0xc2236610},
{0x48,0xda002654},
{0x4c,0xc2002710},
{0x50,0xc2202610},
{0x54,0x80a3600f},
{0x58,0x14800003},
{0x5c,0x9010200f},
{0x60,0x9010000d},
{0x64,0x03000014},
{0x68,0x9e1062a8},
{0x6c,0x82006800},
{0x70,0xa2106330},
{0x74,0x0300003f},
{0x78,0xa61063ff},
{0x7c,0x92022001},
{0xf0,0x82},
{0x00,0xa0102000},
{0x04,0xa410000f},
{0x08,0x972c2002},
{0x0c,0x8203c00b},
{0x10,0xda106002},
{0x14,0x9804400b},
{0x18,0xd4132002},
{0x1c,0xc213c00b},
{0x20,0xd814400b},
{0x24,0x82584008},
{0x28,0x9a5b4008},
{0x2c,0x8200400c},
{0x30,0x9a03400a},
{0x34,0x81800000},
{0x38,0x01000000},
{0x3c,0x01000000},
{0x40,0x01000000},
{0x44,0x82704009},
{0x48,0x81800000},
{0x4c,0x01000000},
{0x50,0x01000000},
{0x54,0x01000000},
{0x58,0x9a734009},
{0x5c,0x83286010},
{0x60,0x9a0b4013},
{0x64,0x8200400d},
{0x68,0xa0042001},
{0x6c,0x80a420b5},
{0x70,0x08bfffe6},
{0x74,0xc222c012},
{0x78,0xd2202654},
{0x7c,0x81c7e008},
{0xf0,0x83},
{0x00,0x81e80000},
{0x04,0x9de3bf98},
{0x08,0xa2102000},
{0x0c,0xc2002514},
{0x10,0x80a44001},
{0x14,0xa0102000},
{0x18,0x1a800012},
{0x1c,0x832c2002},
{0x20,0x92006710},
{0x24,0xc2006710},
{0x28,0x80a06000},
{0x2c,0x02800009},
{0x30,0x90100018},
{0x34,0x7ffff6e9},
{0x38,0x01000000},
{0x3c,0x82102001},
{0x40,0x80a20019},
{0x44,0x1a800003},
{0x48,0x83284010},
{0x4c,0xa2144001},
{0x50,0xa0042001},
{0x54,0xc2002514},
{0x58,0x10bffff0},
{0x5c,0x80a40001},
{0x60,0x81c7e008},
{0x64,0x91e80011},
{0x68,0x9de3bf90},
{0x6c,0x03003fc0},
{0x70,0x82106001},
{0x74,0xc227bff0},
{0x78,0xc027bff4},
{0x7c,0xa0102000},
{0xf0,0x84},
{0x00,0x8207bff8},
{0x04,0x82040001},
{0x08,0xd2487ff9},
{0x0c,0xd0487ff8},
{0x10,0x90060008},
{0x14,0x92064009},
{0x18,0x94102000},
{0x1c,0x7ffff72a},
{0x20,0x9610001a},
{0x24,0x80a22000},
{0x28,0x02800004},
{0x2c,0xa0042001},
{0x30,0x10800006},
{0x34,0xb0102001},
{0x38,0x80a42004},
{0x3c,0x04bffff2},
{0x40,0x8207bff8},
{0x44,0xb0102000},
{0x48,0x81c7e008},
{0x4c,0x81e80000},
{0x50,0x9de3bf98},
{0x54,0xc2102548},
{0x58,0x80886001},
{0x5c,0xb8102000},
{0x60,0xba102000},
{0x64,0x02800004},
{0x68,0xae102000},
{0x6c,0x10800029},
{0x70,0xec002354},
{0x74,0xc200254c},
{0x78,0x80886200},
{0x7c,0x32800010},
{0xf0,0x85},
{0x00,0xc2002690},
{0x04,0x03296956},
{0x08,0xda00250c},
{0x0c,0x8210625a},
{0x10,0x80a34001},
{0x14,0x12800006},
{0x18,0xc20023c8},
{0x1c,0x80886800},
{0x20,0x32800007},
{0x24,0xc2002690},
{0x28,0xc20023c8},
{0x2c,0x80886400},
{0x30,0x22800018},
{0x34,0xec0022ac},
{0x38,0xc2002690},
{0x3c,0x80886200},
{0x40,0x1280000d},
{0x44,0xb8102001},
{0x48,0x13000014},
{0x4c,0x921262a8},
{0x50,0xc2002fd0},
{0x54,0x9fc04000},
{0x58,0xd0002590},
{0x5c,0xc2002fbc},
{0x60,0x9fc04000},
{0x64,0x01000000},
{0x68,0xc2002690},
{0x6c,0x82106200},
{0x70,0xc2202690},
{0x74,0x10800007},
{0x78,0xec0023a0},
{0x7c,0xc200254c},
{0xf0,0x86},
{0x00,0x1b000080},
{0x04,0x8210400d},
{0x08,0x10800084},
{0x0c,0xc220254c},
{0x10,0x7ffff61d},
{0x14,0x901020aa},
{0x18,0xda002500},
{0x1c,0xc20022d0},
{0x20,0x80a34001},
{0x24,0x3880000f},
{0x28,0xba102001},
{0x2c,0xc2002200},
{0x30,0x80a00001},
{0x34,0x9a402000},
{0x38,0x80a00016},
{0x3c,0x82603fff},
{0x40,0x80934001},
{0x44,0x32800007},
{0x48,0xba102001},
{0x4c,0xc2002548},
{0x50,0x80886001},
{0x54,0x02800004},
{0x58,0xaa102000},
{0x5c,0xba102001},
{0x60,0xaa102000},
{0x64,0xa52d6003},
{0x68,0xc204a760},
{0x6c,0x80a06000},
{0x70,0x22800067},
{0x74,0xaa056001},
{0x78,0x80a56000},
{0x7c,0x12800008},
{0xf0,0x87},
{0x00,0x80a76000},
{0x04,0xc200255c},
{0x08,0x80a06000},
{0x0c,0x1280000c},
{0x10,0x29200000},
{0x14,0x1080000a},
{0x18,0xa8102000},
{0x1c,0x02800005},
{0x20,0x9004a760},
{0x24,0xc024a764},
{0x28,0x10800058},
{0x2c,0xc024a760},
{0x30,0x7fffff75},
{0x34,0x92100016},
{0x38,0xa8100008},
{0x3c,0x80a52000},
{0x40,0x02800050},
{0x44,0xae15c014},
{0x48,0xc214a766},
{0x4c,0x80a06000},
{0x50,0x0280000a},
{0x54,0x80a56000},
{0x58,0xc204a764},
{0x5c,0x82007fff},
{0x60,0xc224a764},
{0x64,0xc214a766},
{0x68,0x80a06000},
{0x6c,0x32800048},
{0x70,0xaa056001},
{0x74,0x80a56000},
{0x78,0x12800006},
{0x7c,0x1b004000},
{0xf0,0x88},
{0x00,0xc200254c},
{0x04,0x8210400d},
{0x08,0x10800040},
{0x0c,0xc220254c},
{0x10,0xc2102548},
{0x14,0x80886001},
{0x18,0x02800006},
{0x1c,0x82103fff},
{0x20,0xc024a764},
{0x24,0xc024a760},
{0x28,0x10800038},
{0x2c,0xc2202700},
{0x30,0x80a72000},
{0x34,0x02bfffb2},
{0x38,0xa6102000},
{0x3c,0xc2002514},
{0x40,0x80a4c001},
{0x44,0x1a80002c},
{0x48,0x83350013},
{0x4c,0x80886001},
{0x50,0x02800027},
{0x54,0x9b2ce002},
{0x58,0xe0036710},
{0x5c,0xa3342016},
{0x60,0xa00c2fff},
{0x64,0xa13c2006},
{0x68,0xa20c603f},
{0x6c,0xa0042001},
{0x70,0xa2046001},
{0x74,0x92100011},
{0x78,0xd410246e},
{0x7c,0x7fffff5b},
{0xf0,0x89},
{0x00,0x90100010},
{0x04,0x80a22000},
{0x08,0x92100011},
{0x0c,0x1280000f},
{0x10,0x90100010},
{0x14,0xc210246c},
{0x18,0x94906000},
{0x1c,0x2280000f},
{0x20,0xc200254c},
{0x24,0xc2002548},
{0x28,0x80886080},
{0x2c,0x2280000b},
{0x30,0xc200254c},
{0x34,0x7fffff4d},
{0x38,0x01000000},
{0x3c,0x80a22000},
{0x40,0x22800006},
{0x44,0xc200254c},
{0x48,0x82102001},
{0x4c,0x83284013},
{0x50,0x10800007},
{0x54,0xa82d0001},
{0x58,0x1b000080},
{0x5c,0x8210400d},
{0x60,0xc220254c},
{0x64,0x10800004},
{0x68,0xc02026e8},
{0x6c,0x10bfffd4},
{0x70,0xa604e001},
{0x74,0x80a52000},
{0x78,0x32800005},
{0x7c,0xaa056001},
{0xf0,0x8a},
{0x00,0xc024a764},
{0x04,0xc024a760},
{0x08,0xaa056001},
{0x0c,0x80a56013},
{0x10,0x04bfff96},
{0x14,0xa52d6003},
{0x18,0x80a5e000},
{0x1c,0x22800002},
{0x20,0xc02026e8},
{0x24,0xc200255c},
{0x28,0x80a06000},
{0x2c,0x0280000a},
{0x30,0x80a76000},
{0x34,0xc2002760},
{0x38,0x80a06000},
{0x3c,0x12800006},
{0x40,0x80a76000},
{0x44,0x03000004},
{0x48,0xc2202760},
{0x4c,0xc2002248},
{0x50,0xc2202764},
{0x54,0x1280002b},
{0x58,0xaa102000},
{0x5c,0xc2002514},
{0x60,0x80a54001},
{0x64,0x1a800027},
{0x68,0x96102001},
{0x6c,0x992d6002},
{0x70,0xc2032710},
{0x74,0x8330600c},
{0x78,0x80886001},
{0x7c,0x3280001d},
{0xf0,0x8b},
{0x00,0xaa056001},
{0x04,0x832ac015},
{0x08,0x808dc001},
{0x0c,0x32800019},
{0x10,0xaa056001},
{0x14,0xa6102001},
{0x18,0x9b2ce003},
{0x1c,0xc2036760},
{0x20,0x80a06000},
{0x24,0x1280000f},
{0x28,0xa604e001},
{0x2c,0xc2032710},
{0x30,0xc2236760},
{0x34,0xc2102548},
{0x38,0x80886001},
{0x3c,0x02800004},
{0x40,0x80a72000},
{0x44,0x10800005},
{0x48,0xc2002358},
{0x4c,0x22800003},
{0x50,0xc2002378},
{0x54,0xc200239c},
{0x58,0x10800005},
{0x5c,0xc2236764},
{0x60,0x80a4e013},
{0x64,0x04bfffee},
{0x68,0x9b2ce003},
{0x6c,0xaa056001},
{0x70,0xc2002514},
{0x74,0x80a54001},
{0x78,0x0abfffde},
{0x7c,0x992d6002},
{0xf0,0x8c},
{0x00,0x81c7e008},
{0x04,0x81e80000},
{0x08,0x9de3bf98},
{0x0c,0x7ffff6b4},
{0x10,0x01000000},
{0x14,0xda002548},
{0x18,0x83336010},
{0x1c,0x80886001},
{0x20,0x1280001d},
{0x24,0x8333600c},
{0x28,0x80886001},
{0x2c,0x1280001a},
{0x30,0x01000000},
{0x34,0xc208254d},
{0x38,0x80a06000},
{0x3c,0x02800016},
{0x40,0x033fc180},
{0x44,0xc0204000},
{0x48,0xa0102002},
{0x4c,0x7ffff6fa},
{0x50,0x90102001},
{0x54,0x11000099},
{0x58,0x7ffff1cf},
{0x5c,0x9012233c},
{0x60,0xa0843fff},
{0x64,0x1cbffffa},
{0x68,0x01000000},
{0x6c,0x7ffff6f2},
{0x70,0x90102000},
{0x74,0xc210254c},
{0x78,0x80886001},
{0x7c,0x32800002},
{0xf0,0x8d},
{0x00,0xc020250c},
{0x04,0x7ffff41e},
{0x08,0x90102015},
{0x0c,0x82102001},
{0x10,0xc2202584},
{0x14,0x81c7e008},
{0x18,0x81e80000},
{0x1c,0xc2002588},
{0x20,0x80a06000},
{0x24,0x32800006},
{0x28,0xc200258c},
{0x2c,0xc2002554},
{0x30,0xc2202588},
{0x34,0xc0202594},
{0x38,0xc200258c},
{0x3c,0x80a06000},
{0x40,0x32800006},
{0x44,0xc2102548},
{0x48,0xc2002554},
{0x4c,0xc220258c},
{0x50,0xc0202598},
{0x54,0xc2102548},
{0x58,0x80886001},
{0x5c,0x02800007},
{0x60,0x01000000},
{0x64,0xc2002558},
{0x68,0x80a06001},
{0x6c,0x18800003},
{0x70,0x82102001},
{0x74,0xc2202584},
{0x78,0x81c3e008},
{0x7c,0x01000000},
{0xf0,0x8e},
{0x00,0xc2002548},
{0x04,0x8330600e},
{0x08,0x80886001},
{0x0c,0x12800058},
{0x10,0x98102000},
{0x14,0xc2002514},
{0x18,0x80a30001},
{0x1c,0x1a80000b},
{0x20,0x033fc180},
{0x24,0x96106004},
{0x28,0x832b2002},
{0x2c,0xda006710},
{0x30,0xda20400b},
{0x34,0x98032001},
{0x38,0xc2002514},
{0x3c,0x80a30001},
{0x40,0x0abffffb},
{0x44,0x832b2002},
{0x48,0xda00254c},
{0x4c,0x808b6001},
{0x50,0x32800008},
{0x54,0xc208254e},
{0x58,0xc2002514},
{0x5c,0x9a136001},
{0x60,0x82106100},
{0x64,0xda20254c},
{0x68,0xc2202514},
{0x6c,0xc208254e},
{0x70,0x80a06000},
{0x74,0x3280000b},
{0x78,0xc2082517},
{0x7c,0xc20023c8},
{0xf0,0x8f},
{0x00,0x83306016},
{0x04,0x80886001},
{0x08,0x22800006},
{0x0c,0xc2082517},
{0x10,0xc2002514},
{0x14,0x82106200},
{0x18,0xc2202514},
{0x1c,0xc2082517},
{0x20,0x80a06000},
{0x24,0x2280001d},
{0x28,0xda002514},
{0x2c,0xc2002548},
{0x30,0x80886800},
{0x34,0x22800006},
{0x38,0xd80023c8},
{0x3c,0xc2002514},
{0x40,0x82106400},
{0x44,0xc2202514},
{0x48,0xd80023c8},
{0x4c,0x80a32000},
{0x50,0x16800007},
{0x54,0x8333200c},
{0x58,0xc2002514},
{0x5c,0x1b000004},
{0x60,0x8210400d},
{0x64,0xc2202514},
{0x68,0x8333200c},
{0x6c,0x80886001},
{0x70,0x2280000a},
{0x74,0xda002514},
{0x78,0xc2002540},
{0x7c,0x1b164020},
{0xf0,0x90},
{0x00,0x83286010},
{0x04,0x8200400d},
{0x08,0xda002514},
{0x0c,0x9a134001},
{0x10,0xda202514},
{0x14,0xda002514},
{0x18,0x03000020},
{0x1c,0x808b4001},
{0x20,0x1280000e},
{0x24,0xc0202540},
{0x28,0xc2082517},
{0x2c,0x80a06000},
{0x30,0x32800007},
{0x34,0xc2002500},
{0x38,0xc2002560},
{0x3c,0x80a06000},
{0x40,0x22800007},
{0x44,0xd8082517},
{0x48,0xc2002500},
{0x4c,0x83286010},
{0x50,0x82134001},
{0x54,0xc2202514},
{0x58,0xd8082517},
{0x5c,0xda002514},
{0x60,0x033fc180},
{0x64,0xda204000},
{0x68,0xd8202568},
{0x6c,0x81c3e008},
{0x70,0x01000000},
{0x74,0x9de3bf98},
{0x78,0xd8002548},
{0x7c,0x8333200e},
{0xf0,0x91},
{0x00,0x80886001},
{0x04,0x22800006},
{0x08,0xc2102516},
{0x0c,0x03000010},
{0x10,0x822b0001},
{0x14,0x10800022},
{0x18,0xc2202548},
{0x1c,0x80a06000},
{0x20,0x0280000a},
{0x24,0x9b332003},
{0x28,0x808b2004},
{0x2c,0x2280000e},
{0x30,0xc200231c},
{0x34,0xc2002160},
{0x38,0x80886400},
{0x3c,0x3280000a},
{0x40,0xc200231c},
{0x44,0x9b332003},
{0x48,0x83332002},
{0x4c,0x82086001},
{0x50,0x9a0b6001},
{0x54,0x80a0400d},
{0x58,0x2280000a},
{0x5c,0xc2002560},
{0x60,0xc200231c},
{0x64,0x80a06000},
{0x68,0x22800003},
{0x6c,0xc2082360},
{0x70,0x82102005},
{0x74,0xc2202560},
{0x78,0x10800007},
{0x7c,0x90102001},
{0xf0,0x92},
{0x00,0x80a06000},
{0x04,0x02800004},
{0x08,0x90102000},
{0x0c,0x10bffffa},
{0x10,0x82007fff},
{0x14,0x7ffff648},
{0x18,0x01000000},
{0x1c,0xc2002548},
{0x20,0x9a004001},
{0x24,0x9a0b6008},
{0x28,0x82087ff7},
{0x2c,0x8210400d},
{0x30,0xc2202548},
{0x34,0x81c7e008},
{0x38,0x81e80000},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x00000000},
{0x6c,0x00000000},
{0x70,0x00000000},
{0x74,0x00000000},
{0x78,0x00000000},
{0x7c,0x00000000},
{0xf0,0x93},
{0x00,0x00003670},
{0x04,0xa5010503},
{0x08,0xa5000022},
{0x0c,0x00000000},
{0x10,0x4c494348},
{0x14,0x49444449},
{0x18,0x80cb88ec},
{0x1c,0xbdae39cf},
{0x20,0x864880cd},
{0x24,0xc96fbe71},
{0x28,0x924380d1},
{0x2c,0xc471cce5},
{0x30,0xc9e5c400},
{0x34,0xbc0dbc43},
{0x38,0xc643bd13},
{0x3c,0x00000000},
{0x40,0x00000000},
{0x44,0x00000000},
{0x48,0x00000000},
{0x4c,0x00000000},
{0x50,0x00000000},
{0x54,0x00000000},
{0x58,0x00000000},
{0x5c,0x00000000},
{0x60,0x00000000},
{0x64,0x00000000},
{0x68,0x4a616e20},
{0x6c,0x20382032},
{0x70,0x30313800},
{0x74,0x00000000},
{0x78,0x31343a32},
{0x7c,0x343a3439},


};



#endif

//==========================================================

//esp_lcd_gsl3680.c

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_check.h"
#include "driver/gpio.h"
#include "driver/i2c_master.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_touch.h"
#include "esp_lcd_gsl3680.h"
#include "gsl_point_id.h"

#define TAG "gsl3680"

/* gsl3680 registers */
#define ESP_LCD_TOUCH_GSL3680_READ_XY_REG     (0x80)

/* gsl3680 support key num */
#define ESP_gsl3680_TOUCH_MAX_BUTTONS         (9)


unsigned int gsl_config_data_id[] =
{
	0xccb69a,  
	0x200,
	0,0,
	0,
	0,0,0,
	0,0,0,0,0,0,0,0x1cc86fd6,


	0x40000d00,0xa,0xe001a,0xe001a,0x3200500,0,0x5100,0x8e00,
	0,0x320014,0,0x14,0,0,0,0,
	0x8,0x4000,0x1000,0x10170002,0x10110000,0,0,0x4040404,
	0x1b6db688,0x64,0xb3000f,0xad0019,0xa60023,0xa0002d,0xb3000f,0xad0019,
	0xa60023,0xa0002d,0xb3000f,0xad0019,0xa60023,0xa0002d,0xb3000f,0xad0019,
	0xa60023,0xa0002d,0x804000,0x90040,0x90001,0,0,0,
	0,0,0,0x14012c,0xa003c,0xa0078,0x400,0x1081,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,

	0,//key_map
	0x3200384,0x64,0x503e8,//0
	0,0,0,//1
	0,0,0,//2
	0,0,0,//3
	0,0,0,//4
	0,0,0,//5
	0,0,0,//6
	0,0,0,//7

	0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,


	0x220,
	0,0,0,0,0,0,0,0,
	0x10203,0x4050607,0x8090a0b,0xc0d0e0f,0x10111213,0x14151617,0x18191a1b,0x1c1d1e1f,
	0x20212223,0x24252627,0x28292a2b,0x2c2d2e2f,0x30313233,0x34353637,0x38393a3b,0x3c3d3e3f,
	0x10203,0x4050607,0x8090a0b,0xc0d0e0f,0x10111213,0x14151617,0x18191a1b,0x1c1d1e1f,
	0x20212223,0x24252627,0x28292a2b,0x2c2d2e2f,0x30313233,0x34353637,0x38393a3b,0x3c3d3e3f,

	0x10203,0x4050607,0x8090a0b,0xc0d0e0f,0x10111213,0x14151617,0x18191a1b,0x1c1d1e1f,
	0x20212223,0x24252627,0x28292a2b,0x2c2d2e2f,0x30313233,0x34353637,0x38393a3b,0x3c3d3e3f,

	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,

	0x10203,0x4050607,0x8090a0b,0xc0d0e0f,0x10111213,0x14151617,0x18191a1b,0x1c1d1e1f,
	0x20212223,0x24252627,0x28292a2b,0x2c2d2e2f,0x30313233,0x34353637,0x38393a3b,0x3c3d3e3f,

	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,


	0x3,
	0x101,0,0x100,0,
	0x20,0x10,0x8,0x4,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,

	0x4,0,0,0,0,0,0,0,
	0x3800680,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,
};



static TG_STATE_E tpc_gesture_id = TG_UNKNOWN_STATE;
static XY_DATA_T XY_Coordinate[MAX_FINGER_NUM]={0};
esp_lcd_touch_handle_t esp_lcd_touch_gsl3680;

static uint8_t Finger_num = 0;
static TP_STATE_E tp_event = TP_PEN_NONE;
static uint8_t pre_pen_flag = 0;
static uint32_t pre_distance=0;
static uint32_t distance_flag = 0;
static uint16_t x_new = 0;
static uint16_t y_new = 0;
static uint16_t x_start = 0 , y_start = 0;
static uint8_t zoomOutDebounce = 0;
static uint8_t zoomInDebounce = 0;

static esp_err_t esp_lcd_touch_gsl3680_read_data(esp_lcd_touch_handle_t tp);
static bool esp_lcd_touch_gsl3680_get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);
#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
static esp_err_t esp_lcd_touch_gsl3680_get_button_state(esp_lcd_touch_handle_t tp, uint8_t n, uint8_t *state);
#endif
static esp_err_t esp_lcd_touch_gsl3680_del(esp_lcd_touch_handle_t tp);

/* I2C read/write */
static esp_err_t touch_gsl3680_i2c_read(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len);
static esp_err_t touch_gsl3680_i2c_write(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len);

/* gsl3680 reset */
static esp_err_t touch_gsl3680_reset(esp_lcd_touch_handle_t tp);
/* Read status and config register */
static esp_err_t touch_gsl3680_read_cfg(esp_lcd_touch_handle_t tp);

/* gsl3680 enter/exit sleep mode */
static esp_err_t esp_lcd_touch_gsl3680_enter_sleep(esp_lcd_touch_handle_t tp);
static esp_err_t esp_lcd_touch_gsl3680_exit_sleep(esp_lcd_touch_handle_t tp);
static esp_err_t esp_lcd_touch_gsl3680_startup_chip(esp_lcd_touch_handle_t tp);
static esp_err_t esp_lcd_touch_gsl3680_read_ram_fw(esp_lcd_touch_handle_t tp);
static esp_err_t esp_lcd_touch_gsl3680_load_fw(esp_lcd_touch_handle_t tp);
static esp_err_t esp_lcd_touch_gsl3680_clear_reg(esp_lcd_touch_handle_t tp);
static esp_err_t esp_lcd_touch_gsl3680_init(esp_lcd_touch_handle_t tp);
static TP_STATE_E _Get_Cal_msg(void);

esp_err_t esp_lcd_touch_new_i2c_gsl3680(esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *out_touch)
{
     esp_err_t ret = ESP_OK;

    assert(io != NULL);
    assert(config != NULL);
    assert(out_touch != NULL);

    /* Prepare main structure */
    esp_lcd_touch_gsl3680 = heap_caps_calloc(1, sizeof(esp_lcd_touch_t), MALLOC_CAP_DEFAULT);
    ESP_GOTO_ON_FALSE(esp_lcd_touch_gsl3680, ESP_ERR_NO_MEM, err, TAG, "no mem for GSL3680 controller");

    /* Communication interface */
    esp_lcd_touch_gsl3680->io = io;

    /* Only supported callbacks are set */
    esp_lcd_touch_gsl3680->read_data = esp_lcd_touch_gsl3680_read_data;
    esp_lcd_touch_gsl3680->get_xy = esp_lcd_touch_gsl3680_get_xy;
#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
    esp_lcd_touch_gsl3680->get_button_state = esp_lcd_touch_gsl3680_get_button_state;
#endif
    esp_lcd_touch_gsl3680->del = esp_lcd_touch_gsl3680_del;
    //esp_lcd_touch_gsl3680->enter_sleep = esp_lcd_touch_gsl3680_enter_sleep;
    //esp_lcd_touch_gsl3680->exit_sleep = esp_lcd_touch_gsl3680_exit_sleep;

    /* Mutex */
    esp_lcd_touch_gsl3680->data.lock.owner = portMUX_FREE_VAL;

    /* Save config */
    memcpy(&esp_lcd_touch_gsl3680->config, config, sizeof(esp_lcd_touch_config_t));
    //esp_lcd_touch_io_gsl3680_config_t *gsl3680_config = (esp_lcd_touch_io_gsl3680_config_t *)esp_lcd_touch_gsl3680->config.driver_data;

    /* Prepare pin for touch controller reset */
    if (esp_lcd_touch_gsl3680->config.rst_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t rst_gpio_config = {
            .mode = GPIO_MODE_OUTPUT,
            .pin_bit_mask = BIT64(esp_lcd_touch_gsl3680->config.rst_gpio_num),
        };
        ret = gpio_config(&rst_gpio_config);
        ESP_GOTO_ON_ERROR(ret, err, TAG, "GPIO config failed");
    }

    if (esp_lcd_touch_gsl3680->config.rst_gpio_num != GPIO_NUM_NC && esp_lcd_touch_gsl3680->config.int_gpio_num != GPIO_NUM_NC) {
        /* Prepare pin for touch controller int */
        const gpio_config_t int_gpio_config = {
            .mode = GPIO_MODE_OUTPUT,
            .intr_type = GPIO_INTR_DISABLE,
            .pull_down_en = 0,
            .pull_up_en = 1,
            .pin_bit_mask = BIT64(esp_lcd_touch_gsl3680->config.int_gpio_num),
        };
        ret = gpio_config(&int_gpio_config);
        ESP_GOTO_ON_ERROR(ret, err, TAG, "GPIO config failed");

        ESP_RETURN_ON_ERROR(gpio_set_level(esp_lcd_touch_gsl3680->config.rst_gpio_num, esp_lcd_touch_gsl3680->config.levels.reset), TAG, "GPIO set level error!");
        ESP_RETURN_ON_ERROR(gpio_set_level(esp_lcd_touch_gsl3680->config.int_gpio_num, 0), TAG, "GPIO set level error!");
        vTaskDelay(pdMS_TO_TICKS(10));

        /* Select I2C addr, set output high or low */
        uint32_t gpio_level = 0;
        //if (ESP_LCD_TOUCH_IO_I2C_GSL3680_ADDRESS == gsl3680_config->dev_addr) {
            //gpio_level = 0;
        //} else {
            //gpio_level = 0;
           // ESP_LOGE(TAG, "Addr (0x%X) is invalid", gsl3680_config->dev_addr);
        //}
        ESP_RETURN_ON_ERROR(gpio_set_level(esp_lcd_touch_gsl3680->config.int_gpio_num, gpio_level), TAG, "GPIO set level error!");
        vTaskDelay(pdMS_TO_TICKS(1));

        ESP_RETURN_ON_ERROR(gpio_set_level(esp_lcd_touch_gsl3680->config.rst_gpio_num, !esp_lcd_touch_gsl3680->config.levels.reset), TAG, "GPIO set level error!");
        vTaskDelay(pdMS_TO_TICKS(10));

        vTaskDelay(pdMS_TO_TICKS(50));
    } else {
        ESP_LOGW(TAG, "Unable to initialize the I2C address");
        /* Reset controller */
        ret = touch_gsl3680_reset(esp_lcd_touch_gsl3680);
        ESP_GOTO_ON_ERROR(ret, err, TAG, "GSL3680 reset failed");
    }

    /* Read status and config info */
    ESP_LOGI(TAG,"init gls3680");
    touch_gsl3680_read_cfg(esp_lcd_touch_gsl3680);
    esp_lcd_touch_gsl3680_init(esp_lcd_touch_gsl3680);
    ret = esp_lcd_touch_gsl3680_read_ram_fw(esp_lcd_touch_gsl3680);
    // touch_gsl3680_read_cfg(esp_lcd_touch_gsl3680);

    /* Prepare pin for touch interrupt */
    if (esp_lcd_touch_gsl3680->config.int_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t int_gpio_config = {
            .mode = GPIO_MODE_INPUT,
            .intr_type = (esp_lcd_touch_gsl3680->config.levels.interrupt ? GPIO_INTR_POSEDGE : GPIO_INTR_NEGEDGE),
            .pin_bit_mask = BIT64(esp_lcd_touch_gsl3680->config.int_gpio_num)
        };
        ret = gpio_config(&int_gpio_config);
        ESP_GOTO_ON_ERROR(ret, err, TAG, "GPIO config failed");

        /* Register interrupt callback */
        if (esp_lcd_touch_gsl3680->config.interrupt_callback) {
            esp_lcd_touch_register_interrupt_callback(esp_lcd_touch_gsl3680, esp_lcd_touch_gsl3680->config.interrupt_callback);
        }
    }
 
err:
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Error (0x%x)! Touch controller GSL3680 initialization failed!", ret);
        if (esp_lcd_touch_gsl3680) {
            esp_lcd_touch_gsl3680_del(esp_lcd_touch_gsl3680);
        }
    }

    *out_touch = esp_lcd_touch_gsl3680;

    return ret;

}


static esp_err_t esp_lcd_touch_gsl3680_enter_sleep(esp_lcd_touch_handle_t tp)
{
    // esp_err_t err = touch_gsl3680_i2c_write(tp, ESP_LCD_TOUCH_GSL3680_ENTER_SLEEP, 0x05);
    // ESP_RETURN_ON_ERROR(err, TAG, "Enter Sleep failed!");

    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, 0), TAG, "GPIO set level error!");
        vTaskDelay(pdMS_TO_TICKS(20));
    }

    return ESP_OK;
}

static esp_err_t esp_lcd_touch_gsl3680_exit_sleep(esp_lcd_touch_handle_t tp)
{
    esp_err_t ret;
    ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, 1), TAG, "GPIO set level error!");
    vTaskDelay(pdMS_TO_TICKS(20));


    return ESP_OK;
}

static esp_err_t esp_lcd_touch_gsl3680_read_data(esp_lcd_touch_handle_t tp)
{
    esp_err_t err;
    uint8_t touch_data[24];
    uint8_t touch_cnt = 0;
    uint16_t x_poit, y_poit, x2_poit, y2_poit;
	uint16_t  distance = 0, chazhi = 0;
    size_t i = 0;

    assert(tp != NULL);

// #ifdef USE_GSL_NOID_VERSION
    struct gsl_touch_info cinfo = {0};
    unsigned int tmp1 = 0;
    uint8_t buf[4] = {0};
// #endif

    memset(XY_Coordinate,0,sizeof(XY_Coordinate));

    err = touch_gsl3680_i2c_read(tp, ESP_LCD_TOUCH_GSL3680_READ_XY_REG, touch_data, 24);
    Finger_num = touch_data[0];
    // ESP_LOGI(TAG,"0x80 = %d",touch_data[0]);

    x_poit = ((touch_data[7]&0x0f)<<8 )|touch_data[6];
	y_poit = (touch_data[5]<<8)|touch_data[4];
	x2_poit = ((touch_data[11]&0x0f)<<8 )|touch_data[10];
	y2_poit = (touch_data[9]<<8)|touch_data[8];

// #ifdef USE_GSL_NOID_VERSION
			cinfo.finger_num = Finger_num;	
			cinfo.x[0] = x_poit;
			cinfo.y[0] = y_poit;
			cinfo.id[0] = ((touch_data[7]&0xf0)>>4);
			cinfo.x[1] = x2_poit;
			cinfo.y[1] = y2_poit;
			cinfo.id[1] = ((touch_data[11]&0xf0)>>4);
			cinfo.finger_num = (touch_data[3]<<24)|(touch_data[2]<<16)|
				(touch_data[1]<<8)|touch_data[0];
			
			gsl_alg_id_main(&cinfo);
			tmp1=gsl_mask_tiaoping();
			//SCI_TRACE_LOW("[tp-gsl] tmp1=%x\n", tmp1);
			if(tmp1>0&&tmp1<0xffffffff)
			{
				uint8 addr = 0xf0;
				buf[0]=0xa;buf[1]=0;buf[2]=0;buf[3]=0;
				touch_gsl3680_i2c_write(tp,addr, buf, 4);
				addr = 0x8;
				buf[0]=(uint8)(tmp1 & 0xff);
				buf[1]=(uint8)((tmp1>>8) & 0xff);
				buf[2]=(uint8)((tmp1>>16) & 0xff);
				buf[3]=(uint8)((tmp1>>24) & 0xff);
				//SCI_TRACE_LOW("tmp1=%08x,buf[0]=%02x,buf[1]=%02x,buf[2]=%02x,buf[3]=%02x\n", tmp1,buf[0],buf[1],buf[2],buf[3]);
				touch_gsl3680_i2c_write(tp,addr, buf, 4);
			}
			Finger_num = cinfo.finger_num;	
// #endif


// #ifdef USE_GSL_NOID_VERSION
			XY_Coordinate[0].x_position =  cinfo.x[0];
			XY_Coordinate[0].y_position =  cinfo.y[0];
			XY_Coordinate[0].finger_id = cinfo.id[0];
			XY_Coordinate[1].x_position =  cinfo.x[1];
			XY_Coordinate[1].y_position =  cinfo.y[1];
			XY_Coordinate[1].finger_id = cinfo.id[1];
// #else
// 			XY_Coordinate[0].x_position = x_poit;
// 			XY_Coordinate[0].y_position = y_poit;
// 			XY_Coordinate[1].x_position = x2_poit;
// 			XY_Coordinate[1].y_position = y2_poit;
// #endif
    // i=0;
    // if(Finger_num >0)
    // printf("%s: %d[i], %d[x_position], %d[y_position], %d[finger_id], %d[finger_num]\n",
    //       __func__, i, XY_Coordinate[i].x_position, XY_Coordinate[i].y_position, XY_Coordinate[i].finger_id,Finger_num);
    // i=1;
    // printf("%s: %d[i], %d[x_position], %d[y_position], %d[finger_id], %d[finger_num]\n",
    //       __func__, i, XY_Coordinate[i].x_position, XY_Coordinate[i].y_position, XY_Coordinate[i].finger_id,Finger_num);
    
    if(Finger_num > 1)
	{
		distance_flag ++;
		distance = (x_poit-x2_poit)*(x_poit-x2_poit) + (y_poit-y2_poit)*(y_poit-y2_poit);
		chazhi = distance - pre_distance;
		if(distance_flag >= 3)
		{
			if( chazhi > 900 )
			{
				zoomOutDebounce = 0;
				zoomInDebounce ++;
				if(zoomInDebounce > 3)
				{
					tpc_gesture_id = TG_ZOOM_IN;
					zoomInDebounce = 0;
				}
			}
			else if( chazhi < -900 )
			{
				zoomInDebounce = 0;
				zoomOutDebounce ++;
				if(zoomOutDebounce > 3)
				{
					tpc_gesture_id = TG_ZOOM_OUT;
					zoomOutDebounce = 0;
				}
			}
			else
			{
				tpc_gesture_id = TG_NO_DETECT;
			}
		}

		pre_distance = distance;
		}
	else
		{
		tpc_gesture_id = TG_NO_DETECT;
		distance_flag = 0;
		pre_distance = 0;
		zoomInDebounce = 0;
		zoomOutDebounce = 0;
	}
    
    return ESP_OK;
}

static bool esp_lcd_touch_gsl3680_get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num)
{
    assert(tp != NULL);
    assert(x != NULL);
    assert(y != NULL);
    assert(point_num != NULL);
    assert(max_point_num > 0);

    portENTER_CRITICAL(&tp->data.lock);

    *point_num = Finger_num;
    x[0] = XY_Coordinate[0].x_position;
    y[0] = XY_Coordinate[0].y_position;

    if(Finger_num > 1)
    {
        for(int i=1;i<Finger_num;i++)
        {
            x[i-1] = XY_Coordinate[i].x_position;
            y[i-1] = XY_Coordinate[i].y_position;
            // strength[i] = XY_Coordinate[i].finger_id;
        }
    }
    

    portEXIT_CRITICAL(&tp->data.lock);

    return (*point_num > 0);
}

#if (CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS > 0)
static esp_err_t esp_lcd_touch_gsl3680_get_button_state(esp_lcd_touch_handle_t tp, uint8_t n, uint8_t *state)
{
    esp_err_t err = ESP_OK;
    assert(tp != NULL);
    assert(state != NULL);

    *state = 0;

    portENTER_CRITICAL(&tp->data.lock);

    if (n > tp->data.buttons) {
        err = ESP_ERR_INVALID_ARG;
    } else {
        *state = tp->data.button[n].status;
    }

    portEXIT_CRITICAL(&tp->data.lock);

    return err;
}
#endif

static esp_err_t esp_lcd_touch_gsl3680_del(esp_lcd_touch_handle_t tp)
{
    assert(tp != NULL);

    /* Reset GPIO pin settings */
    if (tp->config.int_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.int_gpio_num);
        if (tp->config.interrupt_callback) {
            gpio_isr_handler_remove(tp->config.int_gpio_num);
        }
    }

    /* Reset GPIO pin settings */
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.rst_gpio_num);
    }

    free(tp);

    return ESP_OK;
}

/*===================================================================================================================================================================================================*/
static esp_err_t esp_lcd_touch_gsl3680_init(esp_lcd_touch_handle_t tp)
{
    ESP_LOGI(TAG,"start init");
    esp_lcd_touch_gsl3680_clear_reg(tp);
    touch_gsl3680_reset(tp);
    esp_lcd_touch_gsl3680_load_fw(tp);
    esp_lcd_touch_gsl3680_startup_chip(tp);
    touch_gsl3680_reset(tp);
    esp_lcd_touch_gsl3680_startup_chip(tp);

    return ESP_OK;
}


static esp_err_t touch_gsl3680_reset(esp_lcd_touch_handle_t tp)
{
    unsigned char write_buf[4];
    uint8_t addr;
    assert(tp != NULL);

    ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, 0), TAG, "GPIO set level error!");
    vTaskDelay(pdMS_TO_TICKS(20));
    ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, 1), TAG, "GPIO set level error!");
    vTaskDelay(pdMS_TO_TICKS(20));

    addr = 0xe0;
    write_buf[0] = 0x88;
    touch_gsl3680_i2c_write(tp,addr,write_buf,1);
    vTaskDelay(pdMS_TO_TICKS(10));
    addr = 0xe4;
    write_buf[0]=0x04;
    touch_gsl3680_i2c_write(tp,addr,write_buf,1);
    vTaskDelay(pdMS_TO_TICKS(10));

    write_buf[0] =0x00;
    write_buf[1] =0x00;
    write_buf[2] =0x00;
    write_buf[3] =0x00;
    touch_gsl3680_i2c_write(tp,0xbc,write_buf,4);

    vTaskDelay(pdMS_TO_TICKS(10));

    return ESP_OK;
}

static esp_err_t touch_gsl3680_read_cfg(esp_lcd_touch_handle_t tp)
{
    uint8_t buf[4];
    uint8_t write[4];
    uint8_t i2c_buffer_read = 0;
    uint8_t i2c_buffer_write = 0x12;
    esp_err_t ret = ESP_OK;

    write[0] = 0x12;
    write[1] = 0x34;
    write[2] = 0x56;
    assert(tp != NULL);

    ESP_LOGI(TAG,"gsl3680 connect");

    ESP_RETURN_ON_ERROR(touch_gsl3680_i2c_read(tp, 0xf0, (uint8_t *)&buf, 4), TAG, "gsl3680 read error!");
    ESP_LOGI(TAG,"gsl3680 read reg 0xf0 before is %x %x %x %x",buf[0],buf[1],buf[2],buf[3]);
    vTaskDelay(pdMS_TO_TICKS(20));
    ESP_LOGI(TAG,"gsl3680 writing 0xf0 0x12");
    ESP_RETURN_ON_ERROR(touch_gsl3680_i2c_write(tp,0xf0,write,4),TAG,"gsl3680 read error");
    vTaskDelay(pdMS_TO_TICKS(20));
    ESP_RETURN_ON_ERROR(touch_gsl3680_i2c_read(tp, 0xf0, (uint8_t *)&buf, 4), TAG, "gsl3680 read error!");
    ESP_LOGI(TAG,"gsl3680 read reg 0xf0 after is %x %x %x %x",buf[0],buf[1],buf[2],buf[3]);

    if(i2c_buffer_read == i2c_buffer_write)
    {
        ret = ESP_OK;
        ESP_LOGI(TAG,"read cfg success");
    }
    else 
        ret = ESP_FAIL;

    return ret;
}

static esp_err_t esp_lcd_touch_gsl3680_startup_chip(esp_lcd_touch_handle_t tp)
{
    esp_err_t ret = ESP_OK;
    uint8_t write_buf[4];
    uint8_t addr = 0xe0;
    write_buf[0] = 0x00;
    ESP_LOGI(TAG,"enter");
    ESP_RETURN_ON_ERROR(touch_gsl3680_i2c_write(tp,addr,write_buf,1),TAG,"gsl3680 read error");
    vTaskDelay(pdMS_TO_TICKS(10));

    gsl_DataInit(gsl_config_data_id);
    return ret;
}

static esp_err_t esp_lcd_touch_gsl3680_read_ram_fw(esp_lcd_touch_handle_t tp)
{
    uint8_t read_buf[4];
    uint8_t addr = 0xb0;
    ESP_LOGI(TAG,"enter read_ram_fw");
    vTaskDelay(pdMS_TO_TICKS(30));
    ESP_RETURN_ON_ERROR(touch_gsl3680_i2c_read(tp, addr, (uint8_t *)&read_buf, 4), TAG, "gsl3680 read error!");
    ESP_LOGI(TAG,"gsl3680 startup_chip failed read 0xb0 = %x,%x,%x,%x ",read_buf[3],read_buf[2],read_buf[1],read_buf[0]);
    if(read_buf[3] != 0x5a || read_buf[2] != 0x5a || read_buf[1] != 0x5a || read_buf[0] != 0x5a)
    {
         
        return ESP_FAIL;
    }
    return ESP_OK;
}

static esp_err_t touch_gsl3680_i2c_read(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len)
{
    assert(tp != NULL);
    assert(data != NULL);


    /* Read data */
    return esp_lcd_panel_io_rx_param(tp->io, reg, data, len);
  
}

static esp_err_t touch_gsl3680_i2c_write(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data,uint8_t len)
{
    assert(tp != NULL);

    // *INDENT-OFF*
    // /* Write data */
    return esp_lcd_panel_io_tx_param(tp->io, reg, data, len);
    // // *INDENT-ON*
}

static esp_err_t esp_lcd_touch_gsl3680_load_fw(esp_lcd_touch_handle_t tp)
{
    ESP_LOGI(TAG,"start load fw");
    uint16_t addr;
    unsigned char wrbuf[4];
    uint16_t source_line = 0;
    uint16_t source_len = sizeof(GSLX680_FW) / sizeof(struct fw_data);

    for(source_line=0;source_line<source_len;source_line++)
    {
        addr = GSLX680_FW[source_line].offset;
        wrbuf[0] = (uint8_t)(GSLX680_FW[source_line].val & 0x000000ff);
        wrbuf[1] = (uint8_t)((GSLX680_FW[source_line].val & 0x0000ff00) >> 8);
        wrbuf[2] = (uint8_t)((GSLX680_FW[source_line].val & 0x00ff0000) >> 16);
        wrbuf[3] = (uint8_t)((GSLX680_FW[source_line].val & 0xff000000) >> 24);
        if(addr == 0xf0)
            touch_gsl3680_i2c_write(tp,addr,wrbuf,1);
        else
            touch_gsl3680_i2c_write(tp,addr,wrbuf,4);
        
    }
    ESP_LOGI(TAG,"load fw success");
    return ESP_OK;
}

static esp_err_t esp_lcd_touch_gsl3680_clear_reg(esp_lcd_touch_handle_t tp)
{
    uint8_t addr;
    uint8_t wrbuf[4];

    ESP_LOGI(TAG,"clear reg");
    addr = 0xe0;
    wrbuf[0] = 0x88;
    touch_gsl3680_i2c_write(tp,addr,wrbuf,1);
    vTaskDelay(pdMS_TO_TICKS(20));
    addr = 0x88;
    wrbuf[0] = 0x01;
    touch_gsl3680_i2c_write(tp,addr,wrbuf,1);
    vTaskDelay(pdMS_TO_TICKS(5));
    addr = 0xe4;
    wrbuf[0] = 0x04;
    touch_gsl3680_i2c_write(tp,addr,wrbuf,1);
    vTaskDelay(pdMS_TO_TICKS(5));
    addr = 0xe0;
    wrbuf[0] = 0x00;
    touch_gsl3680_i2c_write(tp,addr,wrbuf,1);
    vTaskDelay(pdMS_TO_TICKS(20));

    return ESP_OK;
}

static TP_STATE_E _Get_Cal_msg(void)
{
    uint8 pen_flag = 0;
	uint16 x_poit, y_poit, x2_poit, y2_poit;
	int32 x_delta = 0 , y_delta = 0;

	pen_flag = Finger_num;
	x_poit = XY_Coordinate[0].x_position;
	y_poit = XY_Coordinate[0].y_position;
	x2_poit = XY_Coordinate[1].x_position;
	y2_poit = XY_Coordinate[1].y_position;

	if(pen_flag==0)
	{
		if(tp_event == TP_PEN_MOVE)//the last event=move
		{
			x_new = x_poit;
			y_new = y_poit;
		}
		else//the last event=down
		{
			x_new = x_start;
			y_new = y_start;
		}

		tp_event = TP_PEN_UP;
	}
	else if(pen_flag==2)
	{
		tp_event = TP_PEN_DOWN;
		x_start = x_poit;
		y_start = y_poit;
		x_new = x_poit;
		y_new = y_poit;
	}
	else if(pre_pen_flag!=1)//pen_flag=1,pre_pen_flag==0 or 2
	{
		tp_event = TP_PEN_DOWN;
		x_start = x_poit;
		y_start = y_poit;
		x_new = x_poit;
		y_new = y_poit;
	 }
	else// if((pen_flag==1)&&(pre_pen_flag==1))
	{
		x_delta = x_poit - x_start;
		y_delta = y_poit - y_start;
		if((x_delta>20)||(x_delta<-20)||(y_delta>25)||(y_delta<-25))
		{
			tp_event = TP_PEN_MOVE;
		}

		if(tp_event == TP_PEN_MOVE)
		{
			x_new = x_poit;
			y_new = y_poit;
		}
		else
		{
			x_new = x_start;
			y_new = y_start;
		}

	 }

	pre_pen_flag = pen_flag;
	return tp_event;
}

//==============================================================







